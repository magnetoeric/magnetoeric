
 <!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta name="google-site-verification" content="0dfpYjYP37p5-odIMIJFaSXqgC0czlP_NcS4CoK8iew" />
  <meta charset="UTF-8">
  
    <title>艾瑞克</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ericwang">
    

    
    <meta name="description" content="精通java,php,c,c++,andriod,ios等单词的拼写,精通windows,linux,osx等系统的开关机,求一份扫地的工作">
<meta property="og:type" content="website">
<meta property="og:title" content="艾瑞克">
<meta property="og:url" content="http://magnetoeric.github.io/page/3/index.html">
<meta property="og:site_name" content="艾瑞克">
<meta property="og:description" content="精通java,php,c,c++,andriod,ios等单词的拼写,精通windows,linux,osx等系统的开关机,求一份扫地的工作">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="艾瑞克">
<meta name="twitter:description" content="精通java,php,c,c++,andriod,ios等单词的拼写,精通windows,linux,osx等系统的开关机,求一份扫地的工作">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="艾瑞克" title="艾瑞克"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="艾瑞克">艾瑞克</a></h1>
				<h2 class="blog-motto">艾瑞克的小站</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:magnetoeric.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/08/shell-2/" title="shell编程之执行环境" itemprop="url">shell编程之执行环境</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-06-08T08:36:50.000Z" itemprop="datePublished"> 发表于 2016-06-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>文章转自<a href="http://liwei.life/2016/05/30/shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/" target="_blank" rel="external">SHELL编程之执行环境</a></p>
<p>微博ID：<strong>orroz</strong></p>
<p>微信公众号：<strong>Linux系统技术</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是shell编程系列的第三篇，主要介绍bash脚本的执行环境以及注意事项。通过本文，应该可以帮助您解决以下问题：</p>
<ul>
<li>执行bash和执行sh究竟有什么区别？</li>
<li>如何调试bash脚本？</li>
<li>如何记录用户在什么时候执行的某条命令？</li>
<li>为什么有时ulimit命令的设置不生效或者报错？</li>
<li>环境变量和一般变量有什么区别？？</li>
</ul>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><h3 id="交互式login-shell"><a href="#交互式login-shell" class="headerlink" title="交互式login shell"></a>交互式login shell</h3><p>关于bash的编程环境，首先我们要先理解的就是bash的参数。不同方式启动的bash一般默认的参数是不一样的。一般在命令行中使用的bash，都是以login方式打开的，对应的参数是：-l或—login。还有-i参数，表示bash是以交互方式打开的，在默认情况下，不加任何参数的bash也是交互方式打开的。这两种方式都会在启动bash之前加载一些文件：</p>
<p>首先，bash去检查/etc/profile文件是否存在，如果存在就读取并执行这个文件中的命令。</p>
<p>之后，bash再按照以下列出的文件顺序依次查看是否存在这些文件，如果任何一个文件存在，就读取、执行文件中的命令：</p>
<ol>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
</ol>
<p>这里要注意的是，本步骤只会检查到一个文件并处理，即使同时存在2个或3个文件，本步骤也只会处理最优先的那个文件，而忽略其他文件。以上两个步骤的检查都可以用—noprofile参数进行关闭。</p>
<p>当bash是以login方式登录的时候，在bash退出时（exit），会额外读取并执行~/.bash_logout文件中的命令。</p>
<p>当bash是以交互方式登录时（-i参数），bash会读取并执行~/.bashrc中的命令。—norc参数可以关闭这个功能，另外还可以通过—rcfile参数指定一个文件替代默认的~/.bashrc文件。</p>
<p>以上就是bash以login方式和交互式方式登录的主要区别，根据这个过程，我们到RHEL7的环境上看看都需要加载哪些配置：</p>
<p>1.首先是加载/etc/profile。根据RHEL7上此文件内容，这个脚本还需要去检查/etc/profile.d/目录，将里面以.sh结尾的文件都加载一遍。具体细节可以自行查看本文件内容。<br>2.之后是检查~/.bash_profile。这个文件中会加载~/.bashrc文件。<br>3.之后是处理~/.bashrc文件。此文件主要功能是给bash环境添加一些alias，之后再加载/etc/bashrc文件。<br>4.最后处理/etc/bashrc文件。这个过程并不是bash自身带的过程，而是在RHEL7系统中通过脚本调用实现。</p>
<p>了解了这些之后，如果你的bash环境不是在RHEL7系统上，也应该可以确定在自己环境中启动的bash到底加载了哪些配置文件。</p>
<h3 id="bash和sh"><a href="#bash和sh" class="headerlink" title="bash和sh"></a>bash和sh</h3><p>几乎所有人都知道bash有个别名叫sh，也就是说在一个脚本前面写!#/bin/bash和#!/bin/sh似乎没什么不同。但是下面我们要看看它们究竟有什么不同。</p>
<p>首先，第一个区别就是这两个文件并不是同样的类型。如果细心观察过这两个文件的话，大家会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls -l /usr/bin/sh</div><div class="line">lrwxrwxrwx 1 root root 4 11月 24 04:20 /usr/bin/sh -&gt; bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls -l /usr/bin/bash</div><div class="line">-rwxr-xr-x 1 root root 791304 11月 24 04:20 /usr/bin/bash</div></pre></td></tr></table></figure>
<p>sh是指向bash的一个符号链接。符号链接就像是快捷方式，那么执行sh就是在执行bash。这说明什么？说明这两个执行方式是等同的么？实际上并不是。我们都知道在程序中是可以获得自己执行命令的进程名称的，这个方法在bash编程中可以使用$0变量来实现，参见如下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat name.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo $0</div><div class="line"></div><div class="line">case $0 in</div><div class="line">*name.sh)</div><div class="line">echo &quot;My name is name!&quot;</div><div class="line">;;</div><div class="line">*na.sh)</div><div class="line">echo &quot;My name is na&quot; </div><div class="line">;;</div><div class="line">*)</div><div class="line">echo &quot;Name error!&quot;</div><div class="line">;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>这个脚本直接执行的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./name.sh </div><div class="line">./name.sh</div><div class="line">My name is name!</div></pre></td></tr></table></figure>
<p>大家也能看到脚本中有个逻辑是，如果进程名字是以na.sh结尾，那么打印的内容不一样。我们如何能让同一个程序触发这段不同的逻辑呢？其实很简单，就是给这个脚本创建一个叫na.sh的符号链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ln -s name.sh na.sh </div><div class="line">[zorro@zorrozou-pc0 bash]$ ./na.sh </div><div class="line">./na.sh</div><div class="line">My name is na</div></pre></td></tr></table></figure>
<p>通过符号链接的方式改变进程名称是一种常见的编程技巧，我们可以利用这个办法让程序通过不同进程名触发不同处理逻辑。所以大家以后再遇到类似bash和sh这样的符号链接关系的进程时要格外注意它们的区别。在这里它们到底有什么区别呢？实际上bash的源代码中对以bash名称和sh名称执行的时候，会分别触发不同的逻辑，主要的逻辑区别是：以sh名称运行时，会相当于以—posix参数方式启动bash。这个方式跟一般方式的具体区别可以参见：<a href="http://tiswww.case.edu/php/chet/bash/POSIX。" target="_blank" rel="external">http://tiswww.case.edu/php/chet/bash/POSIX。</a></p>
<p>我遇到过很多次因为不同文件名的处理逻辑不同而引发的问题。其中一次是因为posix模式和一般模式的ulimit -c设置不同导致的。ulimit -c参数可以设置进程出现coredump时产生的文件的大小限制。因为内存的页大多都是4k，所以一般core文件都是最小4k一个，当ulimit -c参数设置小于4k时，无法正常产生core文件。为了调试方便，我们的生产系统都开了ulimit -c限制单位为4。因为默认ulimit -c的限制单位是1k，ulimit -c 4就是4k，够用了。但是我们仍然发现部分服务器不能正常产生core文件，最后排查定位到，这些不能产生core文件的配置脚本只要将#!/bin/sh改为#!/bin/bash就可以正常产生core文件。于是郁闷之余，查阅了bash的处理代码，最终发现原来是这个坑导致的问题。原因是：在posix模式下，ulimit -c的参数单位不是1024，而是512。至于还有什么其他不同，在上述链接中都有说明。</p>
<h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><p>程序员对程序的调试工作是必不可少的，bash本身对脚本程序提供的调试手段不多，printf大法是必要技能之一，当然在bash中就是echo大法。另外就是bash的-v参数、-x参数和-n参数。</p>
<p>-v参数就是可视模式，它会在执行bash程序的时候将要执行的内容也打印出来，除此之外，并不改变bash执行的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat arg.sh</div><div class="line">#!/bin/bash -v</div><div class="line"></div><div class="line">echo $0</div><div class="line">echo $1</div><div class="line">echo $2</div><div class="line">ls /123</div><div class="line">echo $3</div><div class="line">echo $4</div><div class="line"></div><div class="line">echo $#</div><div class="line">echo $*</div><div class="line">echo $?</div></pre></td></tr></table></figure>
<p>执行结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./arg.sh 111 222 333 444 555</div><div class="line">#!/bin/bash -v</div><div class="line"></div><div class="line">echo $0</div><div class="line">./arg.sh</div><div class="line">echo $1</div><div class="line">111</div><div class="line">echo $2</div><div class="line">222</div><div class="line">ls /123</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">echo $3</div><div class="line">333</div><div class="line">echo $4</div><div class="line">444</div><div class="line"></div><div class="line">echo $#</div><div class="line">5</div><div class="line">echo $*</div><div class="line">111 222 333 444 555</div><div class="line">echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>-n参数用来检查bash的语法错误，并且不会真正执行bash脚本。这个就不举例子了。另外，三种方式除了可以直接在bash后面加参数以外，还可以在程序中随时使用内建命令set打开和关闭，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat arg.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">set -v</div><div class="line">#set -o verbose</div><div class="line">echo $0</div><div class="line">set +v</div><div class="line">echo $1</div><div class="line">set -x</div><div class="line">#set -o xtrace</div><div class="line">echo $2</div><div class="line">ls /123</div><div class="line">echo $3</div><div class="line">set +x</div><div class="line">echo $4</div><div class="line"></div><div class="line">echo $#</div><div class="line"></div><div class="line">set -n</div><div class="line">#set -o noexec</div><div class="line">echo $*</div><div class="line">echo $?</div><div class="line">set +n</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./arg.sh </div><div class="line">#set -o verbose</div><div class="line">echo $0</div><div class="line">./arg.sh</div><div class="line">set +v</div><div class="line"></div><div class="line">+ echo</div><div class="line"></div><div class="line">+ ls /123</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">+ echo</div><div class="line"></div><div class="line">+ set +x</div><div class="line"></div><div class="line">0</div></pre></td></tr></table></figure>
<p>以上例子中顺便演示了1、3、#、?的意义，大家可以自行对比它们的区别以理解参数的意义。另外再补充一个-e参数，这个参数可以让bash脚本命令执行错误的时候直接退出，而不是继续执行。这个功能在某些调试的场景下非常有用！</p>
<p>本节只列出了几个常用的参数的意义和使用注意事项，希望可以起到抛砖引玉的作用。大家如果想要学习更多的bash参数，可以自行查看bash的man手册，并详细学习set和shopt命令的使用方法。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>我们目前已经知道有个PATH变量，bash会在查找外部命令的时候到PATH所记录的目录中进行查找，从这个例子我们可以先理解一下环境变量的作用。环境变量就类似PATH这种变量，是bash预设好的一些可能会对其状态和行为产生影响的变量。bash中实现的环境变量个数大概几十个，所有的帮助说明都可以在man bash中找到。我们还是拿一些会在bash编程中经常用到的来讲解一下。</p>
<p>我们可以使用env命令来查看当前bash已经定义的环境变量。set命令不加任何参数可以查看当前bash环境中的所有变量，包括环境变量和私有的一般变量。一般变量的定义方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ aaa=1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep aaa</div><div class="line">[zorro@zorrozou-pc0 ~]$ set|grep aaa</div><div class="line">aaa=1000</div></pre></td></tr></table></figure>
<p>上面我们定义了一个变量名字叫做aaa，我们能看到在set命令中可以显示出这个变量，但是env不显示。export命令可以将一个一般变量编程环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ export aaa</div><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep aaa</div><div class="line">aaa=1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ set|grep aaa</div><div class="line">aaa=1000</div></pre></td></tr></table></figure>
<p>export之后，env和set都能看到这个变量了。一般变量和环境变量的区别是：一般变量不能被子进程继承，而环境变量会被子进程继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep aaa</div><div class="line">aaa=1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ bbb=2000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $bbb</div><div class="line">2000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep bbb</div><div class="line">[zorro@zorrozou-pc0 ~]$ bash</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $bbb</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 ~]$</div></pre></td></tr></table></figure>
<p>上面测试中，我们的bash环境里有一个环境变量aaa＝1000，又定义了一个一般变量bbb＝2000。此时我们在用bash打开一个子进程，在子进程中我们发现，aaa变量仍然能取到值，但是bbb不可以。证明aaa可以被子进程继承，bbb不可以。</p>
<p>搞清楚了环境变量的基础知识之后，再来看一下bash中常用的环境变量：</p>
<p>进程自身信息相关</p>
<p>BASH：当前bash进程的进程名。</p>
<p>BASHOPTS：记录了shopt命令已经设置为打开的选项。</p>
<p>BASH_VERSINFO：bash的版本号信息，是一个数组。可以使用命令：echo ${BASH_VERSINFO[*]}查看数组的信息。有关数组的操作我们会在其它文章里详细说明。</p>
<p>BASH_VERSION：bash的版本号信息。比上一个信息更少一点。</p>
<p>HOSTNAME：系统主机名信息。</p>
<p>HOSTTYPE：系统类型信息。</p>
<p>OLDPWD：上一个当前工作目录。</p>
<p>PWD：当前工作目录。</p>
<p>HOME：主目录。一般指进程uid对应用户的主目录。</p>
<p>SHELL：bash程序所在路径。</p>
<p>常用数字</p>
<p>RANDOM：每次取这个变量的值都能得到一个0-32767的随机数。</p>
<p>SECONDS：当前bash已经开启了多少秒。</p>
<p>BASHPID：当前bash进程的PID。</p>
<p>EUID：进程的有效用户id。</p>
<p>GROUPS：进程组身份。</p>
<p>PPID：父进程PID。</p>
<p>UID：用户uid。</p>
<p>提示符</p>
<p>PS1：用户bash的交互提示符，主提示符。</p>
<p>PS2：第二提示符，主要用在一些除了PS1之外常见的提示符场景，比如输入了’之后回车，就能看到这个提示符。</p>
<p>PS3：用于select语句的交互提示符。</p>
<p>PS4：用于跟踪执行过程时的提示符，一般显示为”+”。比如我们在bash中使用set -x之后的跟踪提示就是这个提示符显示的。</p>
<h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>交互bash中提供一种方便追溯曾经使用的命令的功能，叫做命令历史功能。就是将曾经用过的命令纪录下来，以备以后查询或者重复调用。这个功能在交互方式的bash中默认打开，在bash编程环境中默认是没有开启的。可以使用set +H来关闭这个功能，set -H打开这个功能。在开启了history功能的bash中我们可以使用history内建命令查询当前的命令历史列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ history </div><div class="line">1 sudo bash</div><div class="line">2 ps ax</div><div class="line">3 ls</div><div class="line">4 ip ad sh</div></pre></td></tr></table></figure>
<p>命令历史的相关配置都是通过bash的环境变量来完成的：</p>
<p>HISTFILE：记录命令历史的文件路径。</p>
<p>HISTFILESIZE：命令历史文件的行数限制</p>
<p>HISTCONTROL：这个变量可以用来控制命令历史的一些特性。比如一般的命令历史会完全按照我们执行命令的顺序来完整记录，如果我们连续执行相同的命令，也会重复记录，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ history </div><div class="line">......</div><div class="line">1173 pwd</div><div class="line">1174 pwd</div><div class="line">1175 pwd</div><div class="line">1176 history</div></pre></td></tr></table></figure>
<p>我们可以利用这个变量的配置来消除命令历史中的重复记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ export HISTCONTROL=ignoredups</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ history </div><div class="line">1177 export HISTCONTROL=ignoredups</div><div class="line">1178 history </div><div class="line">1179 pwd</div><div class="line">1180 history</div></pre></td></tr></table></figure>
<p>这个变量还有其它配置，ignorespace可以用来让history忽略以空格开头的命令，ignoreboth可以同时起到ignoredups和ignorespace的作用，</p>
<p>HISTIGNORE：可以控制history机制忽略某些命令，配置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HISTIGNORE=”pwd:ls:cd:”。</div></pre></td></tr></table></figure>
<p>HISTSIZE：命令历史纪录的命令个数。</p>
<p>HISTTIMEFORMAT：可以用来定义命令历史纪录的时间格式.在命令历史中记录命令执行时间有时候很有用，配置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HISTTIMEFORMAT=&apos;%F %T &apos;</div></pre></td></tr></table></figure>
<p>相关时间格式的帮助可以查看man 3 strftime。</p>
<p>HISTCMD：当前命令历史的行数。</p>
<p>在交互式操作bash的时候，可以通过一些特殊符号对命令历史进行快速调用，这些符号基本都是以!开头的，除非!后面跟的是空格、换行、等号=或者小括号()：</p>
<p>!n：表示引用命令历史中的第n条命令，如：!123，执行第123条命令。</p>
<p>!-n：表示引用命令历史中的倒数第n条命令，如：!-123，执行倒数第123条命令。</p>
<p>!!：重复执行上一条命令。</p>
<p>!string：在命令历史中找到最近的一条以string字符串开头的命令并执行。</p>
<p>!?string[?]：在命令历史中找到最近的一条包括string字符的命令并执行。如果最有一个?省略的话，就是找到以string结尾的命令。</p>
<p>^string1^string2^：将上一个命令中的string1字符串替换成string2字符串并执行。可以简写为：^string1^string2</p>
<p>!#：重复当前输入的命令。</p>
<p>以下符号可以作为某个命令的单词代号，如：</p>
<p>^：!^表示上一条命令中的第一个参数，$123^表示第123条命令的第一个参数。</p>
<p>$：!$表示上一条命令中的最后一个参数。!123$表示第123条命令的最后一个参数。</p>
<p>n（数字）：!!0表示上一条命令的命令名，!!3上一条命令的第三个参数。!123:3第123条命令的第三个参数。</p>
<p>：表示所有参数，如：!123:\或!123*</p>
<p>x-y：x和y都是数字，表示从第x到第y个参数，如：!123:1-6表示第123条命令的第1个到第6个参数。只写成-y，取前y个，如：!123:-7表示0-7。</p>
<p>x：表示取从第x个参数之后的所有参数，相当于x-$。如：!123:2\</p>
<p>x-：表示取从第x个参数之后的所有参数，不包括最后一个。如：!123:2-</p>
<p>选择出相关命令或者参数之后，我们还可以通过一些命令对其进行操作：</p>
<p>h 删除所有后面的路径，只留下前面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/passwd</div><div class="line">/etc/passwd</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:h</div><div class="line">ls /etc</div><div class="line">...</div></pre></td></tr></table></figure>
<p>紧接着上面的命令执行，相当于运行passwd。</p>
<p>r 删除后缀.xxx, 留下文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls 123.txt</div><div class="line">ls: cannot access &apos;123.txt&apos;: No such file or directory</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:r</div><div class="line">ls 123</div></pre></td></tr></table></figure>
<p>e 删除文件名, 留下后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ !-2:e</div><div class="line">.txt</div><div class="line">bash: .txt: command not found</div></pre></td></tr></table></figure>
<p>p 只打印结果命令，但不执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/passwd</div><div class="line">/etc/passwd</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:p</div><div class="line">ls /etc/passwd</div></pre></td></tr></table></figure>
<p>q 防止代换参数被再次替换，相当于给选择的参数加上了’’，以防止其被转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls `echo /etc/passwd`</div><div class="line">/etc/passwd</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:q</div><div class="line">&apos;ls `echo /etc/passwd`&apos;</div><div class="line">-bash: ls `echo /etc/passwd`: No such file or directory</div></pre></td></tr></table></figure>
<p>x 作用同上，区别是每个参数都会分别给加上’’。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ !-2:x</div><div class="line">&apos;ls&apos; &apos;`echo&apos; &apos;/etc/passwd`&apos;</div><div class="line">ls: cannot access &apos;`echo&apos;: No such file or directory</div><div class="line">ls: cannot access &apos;/etc/passwd`&apos;: No such file or directory</div></pre></td></tr></table></figure>
<p>s/old/new/ 字符串替换，跟上面的^^类似，但是可以指定任意历史命令。只替换找到的第一个old字符串。<br>&amp; 重复上次替换<br>g 在执行s或者＆命令作为前缀使用，表示全局替换。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>每一个进程环境中都有对于资源的限制，bash脚本也不例外。我们可以使用ulimit内建命令查看和设置bash环境中的资源限制。</p>
<p>[zorro@zorrozou-pc0 ~]$ ulimit -a<br>core file size (blocks, -c) unlimited<br>data seg size (kbytes, -d) unlimited<br>scheduling priority (-e) 0<br>file size (blocks, -f) unlimited<br>pending signals (-i) 63877<br>max locked memory (kbytes, -l) 64<br>max memory size (kbytes, -m) unlimited<br>open files (-n) 1024<br>pipe size (512 bytes, -p) 8<br>POSIX message queues (bytes, -q) 819200<br>real-time priority (-r) 0<br>stack size (kbytes, -s) 8192<br>cpu time (seconds, -t) unlimited<br>max user processes (-u) 63877<br>virtual memory (kbytes, -v) unlimited<br>file locks (-x) unlimited</p>
<p>在上文讲述bash和sh之间的区别时，我们已经接触过这个命令中的-c参数了，用来限制core文件的大小。我们再来看看其它参数的含义：</p>
<p>data seg size：程序的数据段限制。</p>
<p>scheduling priority：优先级限制。相关概念的理解可以参考这篇：<a href="http://wp.me/p79Cit-S" target="_blank" rel="external">http://wp.me/p79Cit-S</a></p>
<p>file size：文件大小限制。</p>
<p>pending signals：未决信号个数限制。</p>
<p>max locked memory：最大可以锁内存的空间限制。</p>
<p>max memory size：最大物理内存使用限制。</p>
<p>open files：文件打开个数限制。</p>
<p>pipe size：管道空间限制。</p>
<p>POSIX message queues：POSIX消息队列空间限制。</p>
<p>real-time priority：实时优先级限制。相关概念的理解可以参考这篇：<a href="http://wp.me/p79Cit-S" target="_blank" rel="external">http://wp.me/p79Cit-S</a></p>
<p>stack size：程序栈空间限制。</p>
<p>cpu time：占用CPU时间限制。</p>
<p>max user processes：可以打开的的进程个数限制。</p>
<p>virtual memory：虚拟内存空间限制。</p>
<p>file locks：锁文件个数限制。</p>
<p>以上参数涉及各方面的相关知识，我们在此就不详细描述这些相关内容了。在此我们主要关注open files和max user processes参数，这两个参数是我们在优化系统时最常用的两个参数。</p>
<p>这里需要注意的是，使用ulimit命令配置完这些参数之后的bash产生的子进程都会继承父进程的相关资源配置。ulimit的资源配置的继承关系类似环境变量，父进程的配置变化可以影响子进程。所以，如果我们只是在某个登录shell或者交互式shell中修改了ulimit配置，那么在这个bash环境中执行的命令和产生的子进程都会受到影响，但是对整个系统的其它进程没有影响。如果我们想要让所有用户一登录就有相关的配置，可以考虑把ulimit命令写在bash启动的相关脚本中，如/etc/profile。如果只想影响某一个用户，可以写在这个用户的主目录的bash启动脚本中，如~/.bash_profile。系统的pam模块也给我们提供了配置ulimit相关限制的配置方法，在centos7中大家可以在以下目录和文件中找到相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/security/limits.d/</div><div class="line">10-gcr.conf 99-audio.conf</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/security/limits.conf </div><div class="line">/etc/security/limits.conf</div></pre></td></tr></table></figure>
<p>即使是写在pam相关配置文件中的相关配置，也可能不是系统全局的。如果你想给某一个后台进程设置ulimit，最靠谱的办法还是在它的启动脚本中进行配置。无论如何，只要记得一点，如果相关进程的ulimit没生效，要想的是它的父进程是谁？它的父进程是不是生效了？</p>
<p>ulimit参数中绝大多数配置都是root才有权限改的更大，而非root身份只能在现有的配置基础上减小限制。如果你执行ulimit的时候报错了，请注意是不是这个原因。<br>```</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>通过本文我们学习了bash编程的进程环境的相关内容，主要包括的知识点为：</p>
<ul>
<li>bash的常用参数。</li>
<li>bash的环境变量。</li>
<li>命令历史功能和相关变量配置。</li>
<li>bash脚本的资源限制ulimit的使用。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/24/shell-1/" title="SHELL编程之执行过程" itemprop="url">SHELL编程之执行过程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-24T01:35:00.000Z" itemprop="datePublished"> 发表于 2016-05-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="SHELL编程之执行过程"><a href="#SHELL编程之执行过程" class="headerlink" title="SHELL编程之执行过程"></a>SHELL编程之执行过程</h1><p>每次看这位大大的文章都会收获很多<br>文章转自<a href="http://liwei.life/2016/05/23/shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">SHELL编程之执行过程</a><br>作者相关:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">微博ID：**orroz**</div><div class="line"></div><div class="line">微信公众号：**Linux系统技术**</div></pre></td></tr></table></figure></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是shell编程系列的第二篇，主要介绍bash脚本是如何执行命令的。通过本文，您应该可以解决以下问题：</p>
<ul>
<li><p>脚本开始的#!到底是怎么起作用的？</p>
</li>
<li><p>bash执行过程中的字符串判断顺序究竟是什么样？</p>
</li>
<li><p>如果我们定义了一个函数叫ls，那么调用ls的时候，到底bash是执行ls函数还是ls命令？</p>
</li>
<li><p>内建命令和外建命令到底有什么差别？</p>
</li>
<li><p>程度退出的时候要注意什么？</p>
</li>
</ul>
<h1 id="以魔法-开始"><a href="#以魔法-开始" class="headerlink" title="以魔法#!开始"></a>以魔法#!开始</h1><p>一个脚本程序的开始方式都比较统一，它们几乎都开始于一个#!符号。这个符号的作用大家似乎也都知道，叫做声明解释器。脚本语言跟编译型语言的不一样之处主要是脚本语言需要解释器。因为脚本语言主要是文本，而系统中能够执行的文件实际上都是可执行的二进制文件，就是编译好的文件。文本的好处是人看方便，但是操作系统并不能直接执行，所以就需要将文本内容传递给一个可执行的二进制文件进行解析，再由这个可执行的二进制文件根据脚本的内容所确定的行为进行执行。可以做这种解析执行的二进制可执行程序都可以叫做解释器。</p>
<p>脚本开头的#!就是用来声明本文件的文本内容是交给那个解释器进行解释的。比如我们写bash脚本，一般声明的方法是#!/bin/bash或#!/bin/sh。如果写的是一个python脚本，就用#!/usr/bin/python。当然，在不同环境的系统中，这个解释器放的路径可能不一样，所以固定写一个路径的方式就可能造成脚本在不同环境的系统中不通用的情况，于是就出现了这样的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env 脚本解释器名称</div></pre></td></tr></table></figure>
<p>这就利用了env命令可以得到可执行程序执行路径的功能，让脚本自行找到在当前系统上到底解释器在什么路径。让脚本更具通用性。但是大家有没有想过一个问题，大多数脚本语言都是将#后面出现的字符当作是注释，在脚本中并不起作用。这个#!和这个注释的规则不冲突么？</p>
<p>这就要从#!符号起作用的原因说起，其实也很简单，这个功能是由操作系统的程序载入器做的。在Linux操作系统上，出了1号进程以外，我们可以认为其它所有进程都是由父进程fork出来的。所以对bash来说，所谓的载入一个脚本执行，无非就是父进程调用fork()、exec()来产生一个子进程。这#!就是在内核处理exec的时候进行解析的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">内核中整个调用过程如下（linux 4.4），内核处理exec族函数的主要实现在fs/exec.c文件的do_execveat_common()方法中，其中调用exec_binprm()方法处理执行逻辑，这函数中使用</div><div class="line">search_binary_handler()对要加载的文件进行各种格式的判断，脚本（script）只是其中的一种。确定是script格式后，就会调用script格式对应的load_binary方法：</div><div class="line">load_script()进行处理，#!就是在这个函数中解析的。解析到了#!以后，内核会取其后面的可执行程序路径，再传递给search_binary_handler（）重新解析。</div><div class="line">这样最终找到真正的可执行二进制文件进行相关执行操作。</div></pre></td></tr></table></figure>
<p>因此，对脚本第一行的#!解析，其实是内核给我们变的魔术。#!后面的路径内容在起作用的时候还没有交给脚本解释器。很多人认为#!这一行是脚本解释器去解析的，然而并不是。了解了原理之后，也顺便明白了为什么#!一定要写在第一行的前两个字符，因为这是在内核里写死的，它就只检查前两个字符。当内核帮你选好了脚本解释器之后，后续的工作就都交给解释器做了。脚本的所有内容也都会原封不动的交给解释器再次解释，是的，包括#!。但是由于对于解释器来说，#开头的字符串都是注释，并不生效，所以解释器自然对#!后面所有的内容无感，继续解释对于它来说有意义的字符串去了。</p>
<p>我们可以用一个自显示脚本来观察一下这个事情，什么是自显示脚本？无非就是#!/bin/cat，这样文本的所有内容包括#!行都会交给cat进行显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat cat.sh </div><div class="line">#!/bin/cat</div><div class="line"></div><div class="line">echo &quot;hello world!&quot;</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./cat.sh </div><div class="line">#!/bin/cat</div><div class="line"></div><div class="line">echo &quot;hello world!&quot;</div></pre></td></tr></table></figure>
<p>或者自删除脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat rm.sh </div><div class="line">#!/bin/rm</div><div class="line"></div><div class="line">echo &quot;hello world!&quot;</div><div class="line">[zorro@zorrozou-pc0 bash]$ chmod +x rm.sh </div><div class="line">[zorro@zorrozou-pc0 bash]$ ./rm.sh </div><div class="line">[zorro@zorrozou-pc0 bash]$ cat rm.sh</div><div class="line">cat: rm.sh: No such file or directory</div></pre></td></tr></table></figure>
<p>这就是#!的本质。</p>
<h2 id="bash如何执行shell命令？"><a href="#bash如何执行shell命令？" class="headerlink" title="bash如何执行shell命令？"></a>bash如何执行shell命令？</h2><p>刚才我们从#!的作用原理讲解了一个bash脚本是如何被加载的。就是说当#!/bin/bash的时候，实际上内核给我们启动了一个bash进程，然后把脚本内容都传递给bash进行解析执行。实际上，无论在脚本里还是在命令行中，bash对文本的解析方法大致都是一样的。首先，bash会以一些特殊字符作为分隔符，将文本进行分段解析。最主要的分隔符无疑就是回车，类似功能的分隔符还有分号”;”。所以在bash脚本中是以回车或者分号作为一行命令结束的标志的。这基本上就是第一层级的解析，主要目的是将大段的命令行进行分段。</p>
<p>之后是第二层级解析，这一层级主要是区分所要执行的命令。这一层级主要解析的字符是管道”|”，&amp;&amp;、||这样的可以起到连接命令作用的特殊字符。这一层级解析完后，bash就能拿到最基本的一个个的要执行的命令了。</p>
<p>当然拿到命令之后还要继续第三层解析，这一层主要是区分出要执行的命令和其参数，主要解析的是空格和tab字符。这一层次解析完之后，bash才开始对最基本的字符串进行解释工作。当然，绝大多数解析完的字符串，bash都是在fork之后将其传递给exec进行执行，然后wait其执行完毕之后再解析下一行。这就是bash脚本也被叫做批处理脚本的原因，主要执行过程是一个一个指令串行执行的，上一个执行完才执行下一个。以上这个过程并不能涵盖bash解释字符串的全过程，实际情况要比这复杂。</p>
<p>bash在解释命令的时候为了方便一些操作和提高某些效率做了不少特性，包括alias功能和外部命令路径的hash功能。bash还因为某些功能不能做成外部命令，所以必须实现一些内建命令，比如cd、pwd等命令。当然除了内建命令以外，bash还要实现一些关键字，比如其编程语法结构的if或是while这样的功能。实际上作为一种编程语言，bash还要实现函数功能，我们可以理解为，bash的函数就是将一堆命令做成一个命令，然后调用执行这个名字，bash就是去执行事先封装好的那堆命令。</p>
<p>好吧，问题来了：我们已知有一个内建命令叫做cd，如果此时我们又建立一个alias也叫cd，那么当我在bash中敲入cd并回车之后，bash究竟是将它当成内建命令解释还是当成alias解释？同样，如果cd又是一个外部命令能？如果又是一个hash索引呢？如果又是一个关键字或函数呢？</p>
<p>实际上bash在做这些功能的时候已经安排好了它们在名字冲突的情况下究竟该先以什么方式解释。优先顺序是：</p>
<ol>
<li><p>别名：alias</p>
</li>
<li><p>关键字：keyword</p>
</li>
<li><p>函数：function</p>
</li>
<li><p>内建命令：built in</p>
</li>
<li><p>哈西索引：hash</p>
</li>
<li><p>外部命令：command</p>
</li>
</ol>
<p>这些bash要判断的字符串类型都可以用type命令进行判断，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ type egrep</div><div class="line">egrep is aliased to &apos;egrep --color=auto&apos;</div><div class="line">[zorro@zorrozou-pc0 bash]$ type if</div><div class="line">if is a shell keyword</div><div class="line">[zorro@zorrozou-pc0 bash]$ type pwd</div><div class="line">pwd is a shell builtin</div><div class="line">[zorro@zorrozou-pc0 bash]$ type passwd</div><div class="line">passwd is /usr/bin/passwd</div></pre></td></tr></table></figure>
<h3 id="别名alias"><a href="#别名alias" class="headerlink" title="别名alias"></a>别名alias</h3><p>bash提供了一种别名(alias)功能，可以将某一个字符串做成另一个字符串的别名，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ alias cat=&apos;cat -n&apos;</div><div class="line">[zorro@zorrozou-pc0 bash]$ cat /etc/passwd</div><div class="line">     1  root:x:0:0:root:/root:/bin/bash</div><div class="line">     2  bin:x:1:1:bin:/bin:/usr/bin/nologin</div><div class="line">     3  daemon:x:2:2:daemon:/:/usr/bin/nologin</div><div class="line">     4  mail:x:8:12:mail:/var/spool/mail:/usr/bin/nologin</div><div class="line">     ......</div></pre></td></tr></table></figure>
<p>于是我们再使用cat命令的时候，bash会将其解释为cat -n。</p>
<p>这个功能在交互方式进行bash操作的时候可以提高不少效率。如果我们发现我们常用到某命令的某个参数的时候，就可以将其做成alias，以后就可以方便使用了。交互bash中，我们可以用alias命令查看目前已经有的alias列表。可以用unalias取消这个别名设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ alias </div><div class="line">alias cat=&apos;cat -n&apos;</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ unalias cat</div></pre></td></tr></table></figure>
<p>alias功能在交互打开的bash中是默认开启的，但是在bash脚本中是默认关闭的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#shopt -s expand_aliases</div><div class="line"></div><div class="line">alias ls=&apos;ls -l&apos;</div><div class="line">ls /etc</div></pre></td></tr></table></figure>
<p>此时本程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./alias.sh </div><div class="line">adjtime       cgconfig.conf         docker       group      ifplugd     libao.conf      mail.rc      netconfig       passwd   request-key.conf  shells         udisks2</div><div class="line">adobe         cgrules.conf          drirc   ...</div></pre></td></tr></table></figure>
<p>使用注释行中的shopt -s expand_aliases命令可以打开alias功能支持，我们将这行注释取消掉之后的执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./alias.sh </div><div class="line">total 1544</div><div class="line">-rw-r--r-- 1 root    root        44 11月 13 19:53 adjtime</div><div class="line">drwxr-xr-x 2 root    root      4096 4月  20 09:34 adobe</div><div class="line">-rw-r--r-- 1 root    root       389 4月  18 22:19 appstream.conf</div><div class="line">-rw-r--r-- 1 root    root         0 10月  1 2015 arch-release</div><div class="line">-rw-r--r-- 1 root    root       260 7月   1 2014 asound.conf</div><div class="line">drwxr-xr-x 3 root    root      4096 3月  11 10:09 avahi</div></pre></td></tr></table></figure>
<p>这就是bash的alias功能。</p>
<h3 id="关键字：keyword"><a href="#关键字：keyword" class="headerlink" title="关键字：keyword"></a>关键字：keyword</h3><p>关键字的概念很简单，主要就是bash提供的语法。比如if，while，function等等。对这些关键字使用type命令会显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ type function</div><div class="line">function is a shell keyword</div></pre></td></tr></table></figure>
<p>说明这是一个keyword。我想这个概念没什么可以解释的了，无非就是bash提供的一种语法而已。只是要注意，bash会在判断alias之后才来判断字符串是不是个keyword。就是说，我们还是可以创建一个叫if的alias，并且在执行的时候，bash只把它当成alias看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ alias if=&apos;echo zorro&apos;</div><div class="line">[zorro@zorrozou-pc0 bash]$ if</div><div class="line">zorro</div><div class="line">[zorro@zorrozou-pc0 bash]$ unalias if</div></pre></td></tr></table></figure>
<h3 id="函数：function"><a href="#函数：function" class="headerlink" title="函数：function"></a>函数：function</h3><p>bash在判断完字符串不是一个关键字之后，将会检查其是不是一个函数。在bash编程中，我们可以使用关键字function来定义一个函数，当然这个关键字其实也可以省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name () compound-command [redirection]</div><div class="line">function name [()] compound-command [redirection]</div></pre></td></tr></table></figure>
<p>语法结构中的compound-command一般是放在{}里的一个命令列表（list）。定义好的函数其实就是一系列shell命令的封装，并且它还具有很多bash程序的特征，比如在函数内部可以使用$1，$2等这样的变量来判断函数的参数，也可以对函数使用重定向功能。</p>
<p>关于函数的更细节讨论我们会在后续的文章中展开说明，再这里我们只需要知道它对于bash来说是第几个被解释的即可。</p>
<h3 id="内建命令：built-in"><a href="#内建命令：built-in" class="headerlink" title="内建命令：built in"></a>内建命令：built in</h3><p>在判断完函数之后，bash将查看给的字符串是不是一个内建命令。内建命令是相对于外建命令来说的。其实我们在bash中执行的命令最常见的是外建（外部）命令。比如常见的ls，find，passwd等。这些外建命令的特点是，它们是作为一个可执行程序放在$PATH变量所包含的目录中的。bash在执行这些命令的时候，都会进行fork(),exec()并且wait()。就是用标准的打开子进程的方式处理外部命令。但是内建命令不同，这些命令都是bash自身实现的命令，它们不依靠外部的可执行文件存在。只要有bash，这些命令就可以执行。典型的内建命令有cd、pwd等。大家可以直接help cd或者任何一个内建命令来查看它们的帮助。大家还可以man bash来查看bash相关的帮助，当然也包括所有的内建命令。</p>
<p>其实内建命令的个数并不会很多，一共大概就这些：</p>
<p>:,  ., [, alias, bg, bind, break, builtin, caller, cd, command, compgen, complete, compopt, continue, declare, dirs, disown, echo, enable, eval, exec, exit, export, false, fc,<br>   fg, getopts, hash, help, history, jobs, kill, let, local, logout, mapfile, popd, printf, pushd, pwd, read, readonly, return, set, shift, shopt, source, suspend,  test,  times,  trap,<br>   true, type, typeset, ulimit, umask, unalias, unset, wait</p>
<p>我们在后续的文章中会展开讲解这些命令的功能。</p>
<h3 id="哈西索引：hash"><a href="#哈西索引：hash" class="headerlink" title="哈西索引：hash"></a>哈西索引：hash</h3><p>hash功能实际上是针对外部命令做的一个功能。刚才我们已经知道了，外部命令都是放在$PATH变量对应的路径中的可执行文件。bash在执行一个外部命令时所需要做的操作是：如果发现这个命令是个外部命令就按照$PATH变量中按照目录路径的顺序，在每个目录中都遍历一遍，看看有没有对应的文件名。如果有，就fork、exec、wait。我们系统上一般的$PATH内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $PATH</div><div class="line">/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:</div><div class="line">/usr/bin/vendor_perl:/usr/bin/core_perl:/home/zorro/.local/bin:/home/zorro/bin</div></pre></td></tr></table></figure>
<p>当然，很多系统上的$PATH变量包含的路径可能更多，目录中的文件数量也可能会很多。于是，遍历这些目录去查询文件名的行为就可能比较耗时。于是bash提供了一种功能，就是建立一个bash表，在第一次找到一个命令的路径之后，对其命令名和对应的路径建立一个hash索引。这样下次再执行这个命令的时候，就不用去遍历所有的目录了，只要查询索引就可以更快的找到命令路径，以加快执行程序的速度。</p>
<p>我们可以使用内建命令hash来查看当前已经建立缓存关系的命令和其命中次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ hash</div><div class="line">hits    command</div><div class="line">   1    /usr/bin/flock</div><div class="line">   4    /usr/bin/chmod</div><div class="line">  20    /usr/bin/vim</div><div class="line">   4    /usr/bin/cat</div><div class="line">   1    /usr/bin/cp</div><div class="line">   1    /usr/bin/mkdir</div><div class="line">  16    /usr/bin/man</div><div class="line">  27    /usr/bin/ls</div></pre></td></tr></table></figure>
<p>这个命令也可以对当前的hash表进行操作，-r参数用来清空当前hash表。手工创建一个hash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -p /usr/sbin/passwd psw</div><div class="line">[root@zorrozou-pc0 bash]# psw</div><div class="line">Enter new UNIX password: </div><div class="line">Retype new UNIX password:</div></pre></td></tr></table></figure>
<p>此时我们就可以通过执行psw来执行passwd命令了。查看更详细的hash对应关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -l</div><div class="line">builtin hash -p /usr/bin/netdata netdata</div><div class="line">builtin hash -p /usr/bin/df df</div><div class="line">builtin hash -p /usr/bin/chmod chmod</div><div class="line">builtin hash -p /usr/bin/vim vim</div><div class="line">builtin hash -p /usr/bin/ps ps</div><div class="line">builtin hash -p /usr/bin/man man</div><div class="line">builtin hash -p /usr/bin/pacman pacman</div><div class="line">builtin hash -p /usr/sbin/passwd psw</div><div class="line">builtin hash -p /usr/bin/ls ls</div><div class="line">builtin hash -p /usr/bin/ss ss</div><div class="line">builtin hash -p /usr/bin/ip ip</div></pre></td></tr></table></figure>
<p>删除某一个hash对应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -d psw</div><div class="line">[root@zorrozou-pc0 bash]# hash -l</div><div class="line">builtin hash -p /usr/bin/netdata netdata</div><div class="line">builtin hash -p /usr/bin/df df</div><div class="line">builtin hash -p /usr/bin/chmod chmod</div><div class="line">builtin hash -p /usr/bin/vim vim</div><div class="line">builtin hash -p /usr/bin/ps ps</div><div class="line">builtin hash -p /usr/bin/man man</div><div class="line">builtin hash -p /usr/bin/pacman pacman</div><div class="line">builtin hash -p /usr/bin/ls ls</div><div class="line">builtin hash -p /usr/bin/ss ss</div><div class="line">builtin hash -p /usr/bin/ip ip</div></pre></td></tr></table></figure>
<p>显示某一个hash对应的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -t chmod</div><div class="line">/usr/bin/chmod</div></pre></td></tr></table></figure>
<p>在交互式bash操作和bash编程中，hash功能总是打开的，我们可以用set +h关闭hash功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat hash.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#set +h</div><div class="line"></div><div class="line">hash</div><div class="line"></div><div class="line">hash -p /usr/bin/useradd uad</div><div class="line"></div><div class="line">hash -t uad</div><div class="line"></div><div class="line">uad</div></pre></td></tr></table></figure>
<p>默认打开hash的脚本输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./hash.sh </div><div class="line">hash: hash table empty</div><div class="line">/usr/bin/useradd</div><div class="line">Usage: uad [options] LOGIN</div><div class="line">       uad -D</div><div class="line">       uad -D [options]</div><div class="line"></div><div class="line">Options:</div><div class="line">  -b, --base-dir BASE_DIR       base directory for the home directory of the</div><div class="line">                            new account</div><div class="line">  -c, --comment COMMENT         GECOS field of the new account</div><div class="line">  -d, --home-dir HOME_DIR       home directory of the new account</div><div class="line">  -D, --defaults                print or change default useradd configuration</div><div class="line">  -e, --expiredate EXPIRE_DATE  expiration date of the new account</div><div class="line">  -f, --inactive INACTIVE       password inactivity period of the new account</div><div class="line">  -g, --gid GROUP               name or ID of the primary group of the new</div><div class="line">                            account</div><div class="line">  -G, --groups GROUPS           list of supplementary groups of the new</div><div class="line">                            account</div><div class="line">  -h, --help                    display this help message and exit</div><div class="line">  -k, --skel SKEL_DIR           use this alternative skeleton directory</div><div class="line">  -K, --key KEY=VALUE           override /etc/login.defs defaults</div><div class="line">  -l, --no-log-init             do not add the user to the lastlog and</div><div class="line">                            faillog databases</div><div class="line">  -m, --create-home             create the user&apos;s home directory</div><div class="line">  -M, --no-create-home          do not create the user&apos;s home directory</div><div class="line">  -N, --no-user-group           do not create a group with the same name as</div><div class="line">                            the user</div><div class="line">  -o, --non-unique              allow to create users with duplicate</div><div class="line">                            (non-unique) UID</div><div class="line">  -p, --password PASSWORD       encrypted password of the new account</div><div class="line">  -r, --system                  create a system account</div><div class="line">  -R, --root CHROOT_DIR         directory to chroot into</div><div class="line">  -s, --shell SHELL             login shell of the new account</div><div class="line">  -u, --uid UID                 user ID of the new account</div><div class="line">  -U, --user-group              create a group with the same name as the user</div></pre></td></tr></table></figure>
<p>关闭hash之后的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./hash.sh </div><div class="line">./hash.sh: line 5: hash: hashing disabled</div><div class="line">./hash.sh: line 7: hash: hashing disabled</div><div class="line">./hash.sh: line 9: hash: hashing disabled</div><div class="line">./hash.sh: line 11: uad: command not found</div></pre></td></tr></table></figure>
<h3 id="外部命令：command"><a href="#外部命令：command" class="headerlink" title="外部命令：command"></a>外部命令：command</h3><p>除了以上说明之外的命令都会当作外部命令处理。执行外部命令的固定动作就是在$PATH路径下找命令，找到之后fork、exec、wait。如果没有这个可执行文件名，就报告命令不存在。这也是bash最后去判断的字符串类型。</p>
<p>外建命令都是通过fork调用打开子进程执行的，所以bash单纯只用外建命令是不能实现部分功能的。比如大家都知道cd命令是用来修改当前进程的工作目录的，如果这个功能使用外部命令实现，那么进程将fork打开一个子进程，子进程通过chdir()进行当前工作目录的修改时，实际上只改变了子进程本身的当前工作目录，而父进程bash的工作目录没变。之后子进程退出，返回到父进程的交互操作环境之后，用户会发现，当前的bash的pwd还在原来的目录下。所以大家应该可以理解，虽然我们的原则是尽量将所有命令都外部实现，但是还是有一些功能不能以创建子进程的方式达到目的，那么这些功能就必须内部实现。这就是内建命令必须存在的原因。另外要注意：bash在正常调用内部命令的时候并不会像外部命令一样产生一个子进程。</p>
<h2 id="脚本的退出"><a href="#脚本的退出" class="headerlink" title="脚本的退出"></a>脚本的退出</h2><p>一个bash脚本的退出一般有多种方式，比如使用exit退出或者所有脚本命令执行完之后退出。无论怎么样退出，脚本都会有个返回码，而且返回码可能不同。</p>
<p>任何命令执行完之后都有返回码，主要用来判断这个命令是否执行成功。在交互中bash中，我们可以使用$?来查看上一个命令的返回码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /123</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $?</div><div class="line">2</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls /</div><div class="line">bin  boot  cgroup  data  dev  etc  home  lib  lib64  lost+found  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>返回码逻辑上有两类，0为真，非零为假。就是说，返回为0表示命令执行成功，非零表示执行失败。返回码的取值范围为0-255。其中错误返回码为1-255。bash为我们提供了一个内建命令exit，通过中这个命令可以人为指定退出的返回码是多少。这个命令的使用是一般进行bash编程的运维人员所不太注意的。我们在上一篇的bash编程语法结构的讲解中说过，if、while语句的条件判断实际上就是判断命令的返回值，如果我们自己写的bash脚本不注意规范的使用脚本退出时的返回码的话，那么这样的bash脚本将可能不可以在别人编写脚本的时候，直接使用if将其作为条件判断，这可能会对程序的兼容性造成影响。因此，请大家注意自己写的bash程序的返回码状态。如果我们的bash程序没有显示的以一个exit指定返回码退出的话，那么其最后执行命令的返回码将成为整个bash脚本退出的返回码。</p>
<p>当然，一个bash程序的退出还可能因为被中间打断而发生，这一般是因为进程接收到了一个需要程序退出的信号。比如我们日常使用的ctrl＋c操作，就是给进程发送了一个2号SIGINT信号。考虑到程序退出可能性的各种可能，系统将错误返回码设计成1-255，这其中还分成两类：</p>
<ul>
<li>程序退出的返回码：1-127。这部分返回码一般用来作为给程序员自行设定错误退出用的返回码，比如：如果一个文件不存在，ls将返回2。如果要执行的命令不存在，则bash统一返回127<br>。返回码125和126有特殊用处，一个是程序命令不存在的返回码，另一个是命令的文件在，但是不可执行的返回码。</li>
<li>程序被信号打断的返回码：128-255。这部分系统习惯上是用来表示进程被信号打断的退出返回码的。一个进程如果被信号打断了，其退出返回码一般是128+信号编号的数字。</li>
</ul>
<p>比如说，如果一个进程被2号信号打断的话，其返回码一般是128+2=130。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ sleep 1000</div><div class="line">^C</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $?</div><div class="line">130</div></pre></td></tr></table></figure>
<p>在执行sleep命令的过程中，我使用ctrl+c中断了进程的执行。此时返回值为130。可以用内建命令kill -l查看所有信号和其对应的编号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ kill -l</div><div class="line"> 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP</div><div class="line"> 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1</div><div class="line">11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM</div><div class="line">16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP</div><div class="line">21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ</div><div class="line">26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR</div><div class="line">31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</div><div class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</div><div class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</div><div class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</div><div class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</div><div class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</div><div class="line">63) SIGRTMAX-1  64) SIGRTMAX</div></pre></td></tr></table></figure>
<p>在我们编写bash脚本的时候，一般可以指定的返回码范围是1-124。建议大家养成编写返回码的编程习惯，但是系统并不对这做出限制，作为程序员你依然可以使用0-255的所有返回码。但是如果你滥用这些返回码，很可能会给未来程序的扩展造成不必要的麻烦。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文中我们描述了一个脚本的执行过程，从#!开始，到中间的解析过程，再到最后的退出返回码。希望这些对大家深入理解bash的执行过程和编写更高质量的脚本有帮助。通过本文我们明确了以下知识点：</p>
<ul>
<li>脚本开始的#!的作用原理。</li>
<li>bash的字符串解析过程。</li>
<li>什么是alias。</li>
<li>什么是关键字。</li>
<li>什么是function。</li>
<li>什么是内建命令，hash和外建命令以及它们的执行方法。</li>
<li>如何退出一个bash脚本以及返回码的含义。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/22/ansible/" title="初试ansible" itemprop="url">初试ansible</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-22T11:35:00.000Z" itemprop="datePublished"> 发表于 2016-05-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="ansible使用"><a href="#ansible使用" class="headerlink" title="ansible使用"></a>ansible使用</h1><p>ansible可以作为自动化运维工具，一直以来都是知道有这东西，却没有尝试过，现在是时候把吹过的牛逼补回来了</p>
<p>1、简介</p>
<p>ansible是自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。主要包括：</p>
<ul>
<li><p>连接插件connection plugins：负责和被监控端实现通信；</p>
</li>
<li><p>host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；</p>
</li>
<li><p>各种模块核心模块、command模块、自定义模块；</p>
</li>
<li><p>借助于插件完成记录日志邮件等功能；</p>
</li>
<li><p>playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>略过了，使用pip，安装很简单</p>
<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p><img src="http://githubforericwang.qiniudn.com/hexo/eric/wKiom1Rsxz3ToUCAAAGROYAM3EI989.jpg" alt=""></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>no agents：不需要在被管控主机上安装任何客户端；</p>
</li>
<li><p>no server：无服务器端，使用时直接运行命令即可；</p>
</li>
<li><p>modules in any languages：基于模块工作，可使用任意语言开发模块；</p>
</li>
<li><p>yaml，not code：使用yaml语言定制剧本playbook；</p>
</li>
<li><p>ssh by default：基于SSH工作；</p>
</li>
<li><p>strong multi-tier solution：可实现多级指挥。</p>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；</li>
<li>批量任务执行可以写成脚本，而且不用分发到远程就可以执行；</li>
<li>使用python编写，维护更简单，ruby语法过于复杂；</li>
<li>支持sudo。</li>
</ul>
<h2 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h2><p><img src="http://githubforericwang.qiniudn.com/hexo/eric/wKiom1Rsx2uQYJZ5AAJplY08vOQ976.jpg" alt=""></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="搭建多个可操作的host"><a href="#搭建多个可操作的host" class="headerlink" title="搭建多个可操作的host"></a>搭建多个可操作的host</h3><p>没有机器，暂时用docker替代了<br>一个简单的sshd的Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FROM ubuntu:14.04</div><div class="line">MAINTAINER ericwang 123048591@qq.com</div><div class="line">RUN apt-get update &amp;&amp; apt-get install -y openssh-server \</div><div class="line">   &amp;&amp; sed -i &apos;s/UsePAM yes/UsePAM no/g&apos; /etc/ssh/sshd_config  \</div><div class="line">   &amp;&amp; useradd ansible \</div><div class="line">   &amp;&amp; echo ansible:ansible |chpasswd \</div><div class="line">   &amp;&amp; echo &quot;admin   ALL=(ALL)       ALL&quot; &gt;&gt; /etc/sudoers  \</div><div class="line">   &amp;&amp; mkdir /var/run/sshd</div><div class="line">RUN ssh-keygen  -t rsa -f /root/.ssh/id_rsa -P &quot;&quot;</div><div class="line">EXPOSE 22</div><div class="line">CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;]</div></pre></td></tr></table></figure>
<p>build脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">docker build  --tag sshd-server ./</div></pre></td></tr></table></figure>
<p>run脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">set -x</div><div class="line">container_id=$(docker run -itd -P sshd-server)</div><div class="line">cat ~/.ssh/id_rsa.pub | docker exec --user=root -i $container_id  sh -c &apos;cat &gt;&gt; /root/.ssh/authorized_keys&apos;</div><div class="line">docker exec $container_id chmod 600 /root/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<p>练习的时候才发现docker exec使用流的时候有些问题，google看到<a href="https://forums.docker.com/t/docker-exec-api-using-stdin-to-upload-a-file/748" target="_blank" rel="external">这篇文章</a>，直接使用exec command &gt;&gt; file这种形式是不行的，会把流输出到宿主系统，完全就是错误的。期待那位linux　大神继续更新shell相关的博文，更深入地理解linux</p>
<p>./build.sh 创建image,然后,./run.sh　这就创建了一个容器,也就是用来测试的ansible host。多次run后，就有了多个host机器了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line"></div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                      NAMES</div><div class="line">a57b8c69e513        sshd-server         &quot;/usr/sbin/sshd -D&quot;      35 seconds ago      Up 34 seconds       0.0.0.0:32784-&gt;22/tcp      serene_saha</div></pre></td></tr></table></figure>
<p>每一次run后都会产生一个容器,将端口22映射到主机的一个端口上，可以通过ssh登陆到docker容器中<br>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ ssh root@127.0.0.1 -p 32784</div><div class="line">The authenticity of host &apos;[127.0.0.1]:32784 ([127.0.0.1]:32784)&apos; can&apos;t be established.</div><div class="line">ECDSA key fingerprint is 6a:d1:27:e4:89:93:98:96:8f:02:f7:bf:6e:d7:eb:7b.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;[127.0.0.1]:32784&apos; (ECDSA) to the list of known hosts.</div><div class="line">root@a57b8c69e513:~#</div></pre></td></tr></table></figure></p>
<p>第一次登陆需要add到know hosts，以后就是免密码登陆了</p>
<p>启动了２个docker容器后,接下来是配置ansible了<br>默认hosts是在/etc/ansible/hosts,添加一组远程主机地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ cat /etc/ansible/hosts </div><div class="line">[docker]</div><div class="line">[docker]</div><div class="line">127.0.0.1:32787 ansible_connection=ssh        ansible_ssh_user=root</div></pre></td></tr></table></figure>
<p>关于inventory的配置，这个<a href="http://sapser.github.io/ansible/2014/07/10/ansible-inventory/" target="_blank" rel="external">博客</a>写的很详尽</p>
<p>接下来尝试写playbook，<a href="http://sapser.github.io/ansible/2014/07/21/ansible-playbook/" target="_blank" rel="external">这篇</a>介绍的也不错。<br>写了一个简单的目录传输的playbook，很简单，功能很简单(其实就是发布系统的目录推送部分，其他功能待完善)<br>ansible目录下的两个文件,push_code.yml,update_git_code.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  ansible cat push_code.yml </div><div class="line">---</div><div class="line">- hosts: docker</div><div class="line">  remote_user: root</div><div class="line">  tasks:</div><div class="line">  - name: push data</div><div class="line">    copy: src=/data/git_code dest=/data/code/</div><div class="line">            owner=root group=root mode=0644</div></pre></td></tr></table></figure>
<p>然后写一个简单的主机发送脚本吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  ansible cat update_git_code.sh </div><div class="line">#!/bin/bash</div><div class="line">set -x</div><div class="line">cd dirname $0</div><div class="line">git_dir=/data/git_code/</div><div class="line">git --git-dir=$git_dir.git/ --work-tree=$git_dir pull --rebase origin master:master \</div><div class="line">&amp;&amp; ansible-playbook -check  push_code.yml</div></pre></td></tr></table></figure>
<p>/data/git_code是预先建立好的git代码仓库。这样就实现了一个简单的发布系统。后面有时间结合下之前做的docker-laravel,搞一个自动化的吧</p>
<p>ansible在github上也有关于lamp的例子<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="external">ansible-examples</a></p>
<p>就先这样吧　以后有机会再继续接触</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://sofar.blog.51cto.com/353572/1579894/" target="_blank" rel="external">自动化运维工具Ansible详细部署</a><br><a href="http://docs.ansible.com" target="_blank" rel="external">ansible 官方文档</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/ansible/">ansible</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/18/shell/" title="shell 编程之语法基础" itemprop="url">shell 编程之语法基础</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-18T01:35:00.000Z" itemprop="datePublished"> 发表于 2016-05-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>文章转自<a href="http://liwei.life/2016/05/16/69/" target="_blank" rel="external">SHELL编程之语法基础</a></p>
<p>微博ID：<strong>orroz</strong></p>
<p>微信公众号：<strong>Linux系统技术</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在此需要特别注明一下，本文叫做shell编程其实并不准确，更准确的说法是bash编程。考虑到bash的流行程度，姑且将bash编程硬说成shell编程也应没什么不可，但是请大家一定要清楚，shell编程绝不仅仅只是bash编程。</p>
<p>通过本文可以帮你解决以下问题：</p>
<ul>
<li>if后面的中括号[]是语法必须的么？</li>
<li>为什么bash编程中有时[]里面要加空格，有时不用加？如if [ -e /etc/passwd ]或ls [abc].sh。</li>
<li>为什么有人写的脚本这样写：if [ x$test = x”string” ]？</li>
<li>如何用*号作为通配符对目录树递归匹配？</li>
<li>为什么在for循环中引用ls命令的输出是可能有问题的？就是说：for i in $(ls /)这样用有问题？</li>
</ul>
<p>除了以上知识点以外，本文还试图帮助大家用一个全新的角度对bash编程的知识进行体系化。介绍shell编程传统的做法一般是要先说明什么是shell？什么是bash？这是种脚本语言，那么什么是脚本语言？不过这些内容真的太无聊了，我们快速掠过，此处省略3万字……作为一个实践性非常强的内容，我们直接开始讲语法。所以，这并不是一个入门内容，我们的要求是在看本文之前，大家至少要学会Linux的基本操作，并知道bash的一些基础知识。</p>
<h2 id="if分支结构"><a href="#if分支结构" class="headerlink" title="if分支结构"></a>if分支结构</h2><p>组成一个语言的必要两种语法结构之一就是分支结构，另一种是循环结构。作为一个编程语言，bash也给我们提供了分支结构，其中最常用的就是if。用来进行程序的分支逻辑判断。其原型声明为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if list; then list; elif list; then list; ... else list; fi</div></pre></td></tr></table></figure>
<p>bash在解析字符的时候，对待“;”跟看见回车是一样的行为，所以这个语法也可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if list</div><div class="line">then</div><div class="line">    list</div><div class="line">elif list</div><div class="line">then</div><div class="line">    list</div><div class="line">...</div><div class="line">else</div><div class="line">    list</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>对于这个语法结构，需要重点说明的是list。对于绝大多数其他语言，if关键字后面一般跟的是一个表达式，比如C语言或类似语言的语法，if后面都是跟一个括号将表达式括起来，如：if (a &gt; 0)。这种认识会对学习bash编程造成一些误会，很多初学者都认为bash编程的if语法结构是：if [ ];then…，但实际上这里的中括号[]并不是C语言中小括号()语法结构的类似的关键字。这里的中括号其实就是个shell命令，是test命令的另一种写法。严谨的叙述，if后面跟的就应该是个list。那么什么是bash中的list呢？根据bash的定义，list就是若干个使用管道，；，&amp;，&amp;&amp;，||这些符号串联起来的shell命令序列，结尾可以；，&amp;或换行结束。这个定义可能比较复杂，如果暂时不能理解，大家直接可以认为，if后面跟的就是个shell命令。换个角度说，bash编程仍然贯彻了C程序的设计哲学，即：一切皆表达式。</p>
<p>一切皆表达式这个设计原则，确定了shell在执行任何东西（注意是任何东西，不仅是命令）的时候都会有一个返回值，因为根据表达式的定义，任何表达式都必须有一个值。在bash编程中，这个返回值也限定了取值范围：0-255。跟C语言含义相反，bash中0为真（true），非0为假（false）。这就意味着，任何给bash之行的东西，都会反回一个值，在bash中，我们可以使用关键字$?来查看上一个执行命令的返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ ls /tmp/</div><div class="line">plugtmp  systemd-private-bfcfdcf97a4142e58da7d823b7015a1f-colord.service-312yQe  systemd-private-bfcfdcf97a4142e58da7d823b7015a1f-systemd-timesyncd.service-zWuWs0  tracker-extract-files.1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $?</div><div class="line">0</div><div class="line">[zorro@zorrozou-pc0 ~]$ ls /123</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $?</div><div class="line">2</div></pre></td></tr></table></figure>
<p>可以看到，ls /tmp命令执行的返回值为0，即为真，说明命令执行成功，而ls /123时文件不存在，反回值为2，命令执行失败。我们再来看个更极端的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ abcdef</div><div class="line">bash: abcdef: command not found</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $?</div><div class="line">127</div></pre></td></tr></table></figure>
<p>我们让bash执行一个根本不存在的命令abcdef。反回值为127，依然为假，命令执行失败。复杂一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ ls /123|wc -l</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">0</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>这是一个list的执行，其实就是两个命令简单的用管道串起来。我们发现，这时shell会将整个list看作一个执行体，所以整个list就是一个表达式，那么最后只返回一个值0，这个值是整个list中最后一个命令的返回值，第一个命令执行失败并不影响后面的wc统计行数，所以逻辑上这个list执行成功，返回值为真。</p>
<p>理解清楚这一层意思，我们才能真正理解bash的语法结构中if后面到底可以判断什么？事实是，判断什么都可以，因为bash无非就是把if后面的无论什么当成命令去执行，并判断其起返回值是真还是假？如果是真则进入一个分支，为假则进入另一个。基于这个认识，我们可以来思考以下这个程序两种写法的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">DIR=&quot;/etc&quot;</div><div class="line">＃第一种写法</div><div class="line">ls -l $DIR &amp;&gt; /dev/null</div><div class="line">ret=$?</div><div class="line"></div><div class="line">if [ $ret -eq 0 ]</div><div class="line">then</div><div class="line">        echo &quot;$DIR is exist!&quot; </div><div class="line">else</div><div class="line">        echo &quot;$DIR is not exist!&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">#第二种写法</div><div class="line">if ls -l $DIR &amp;&gt; /dev/null</div><div class="line">then</div><div class="line">        echo &quot;$DIR is exist!&quot; </div><div class="line">else</div><div class="line">        echo &quot;$DIR is not exist!&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>我曾经在无数的脚本中看到这里的第一种写法，先执行某个命令，然后记录其返回值，再使用[]进行分支判断。我想，这样写的人应该都是没有真正理解if语法的语义，导致做出了很多脱了裤子再放屁的事情。当然，if语法中后面最常用的命令就是[]。请注意我的描述中就是说[]是一个命令，而不是别的。实际上这也是bash编程新手容易犯错的地方之一，尤其是有其他编程经验的人，在一开始接触bash编程的时候都是将[]当成if语句的语法结构，于是经常在写[]的时候里面不写空格，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#正确的写法</div><div class="line">if [ $ret -eq 0 ]</div><div class="line">＃错误的写法</div><div class="line">if [$ret -eq 0]</div></pre></td></tr></table></figure>
<p>同样的，当我们理解清楚了[]本质上是一个shell命令的时候，大家就知道这个错误是为什么了：命令加参数要用空格分隔。我们可以用type命令去检查一个命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ type [</div><div class="line">[ is a shell builtin</div></pre></td></tr></table></figure>
<p>所以，实际上[]是一个内建命令，等同于test命令。所以上面的if语句也可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if test $ret -eq 0</div></pre></td></tr></table></figure>
<p>这样看，形式上就跟第二种写法类似了。至于if分支怎么使用的其它例子就不再这废话了。重要的再强调一遍：if后面是一个命令(严格来说是list)，并且记住一个原则：一切皆表达式。</p>
<h2 id="“当”、“直到”循环结构"><a href="#“当”、“直到”循环结构" class="headerlink" title="“当”、“直到”循环结构"></a>“当”、“直到”循环结构</h2><p>一般角度的讲解都会在讲完if分支结构之后讲其它分支结构，但是从执行特性和快速上手的角度来看，我认为先把跟if特性类似的while和until交代清楚更加合理。从字面上可以理解，while就是“当”型循环，指的是当条件成立时执行循环。，而until是直到型循环，其实跟while并没有实质上的区别，只是条件取非，逻辑变成循环到条件成立，或者说条件不成立时执行循环体。他们的语法结构是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while list-1; do list-2; done</div><div class="line">until list-1; do list-2; done</div></pre></td></tr></table></figure>
<p>同样，分号可以理解为回车，于是常见写法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">while list-1</div><div class="line">do</div><div class="line">    list-2</div><div class="line">done</div><div class="line"></div><div class="line">until list-1</div><div class="line">do</div><div class="line">    list-2</div><div class="line">done</div></pre></td></tr></table></figure>
<p>还是跟if语句一样，我们应该明白对与while和until的条件的含义，仍然是list。其判断条件是list，其执行结构也是list。理解了上面if的讲解，我想这里应该不用复述了。我们用while和unitl来产生一个0-99的数字序列：<br>while版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">count=0</div><div class="line"></div><div class="line">while [ $count -le 100 ]</div><div class="line">do</div><div class="line">    echo $count</div><div class="line">    count=$[$count+1]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>until版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">count=0</div><div class="line"></div><div class="line">until ! [ $count -le 100 ]</div><div class="line">do</div><div class="line">    echo $count</div><div class="line">    count=$[$count+1]</div><div class="line">done</div></pre></td></tr></table></figure>
<p>我们通过这两个程序可以再次对比一下while和until到底有什么不一样？其实它们从形式上完全一样。这里另外说明两个知识点：</p>
<ul>
<li><p>在bash中，叹号（!）代表对命令(表达式)的返回值取反。就是说如果一个命令或list或其它什么东西如果返回值为真，<br>加了叹号之后就是假，如果是假，加了叹号就是真。</p>
</li>
<li><p>在bash中，使用$[]可以得到一个算数运算的值。可以支持常用的5则运算（+-*/%）。<br>用法就是$[3+7]类似这样，而且要注意，这里的$[]里面没有空格分隔，因为它并不是个shell命令，而是特殊字符。</p>
</li>
</ul>
<p>常见运算例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[213+456]</div><div class="line">669</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[213+456+789]</div><div class="line">1458</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[213*456]</div><div class="line">97128</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[213/456]</div><div class="line">0</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[9/3]</div><div class="line">3</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[9/2]</div><div class="line">4</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[9%2]</div><div class="line">1</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[144%7]</div><div class="line">4</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $[7-10]</div><div class="line">-3</div></pre></td></tr></table></figure>
<p>注意这个运算只支持整数，并且对与小数只娶其整数部分（没有四舍五入，小数全舍）。这个计算方法是bash提供的基础计算方法，如果想要实现更高级的计算可以使用let命令。如果想要实现浮点数运算，我一般使用awk来处理。</p>
<p>上面的例子中仍然使用[]命令（test）来作为检查条件，我们再试一个别的。假设我们想写一个脚本检查一台服务器是否能ping通？如果能ping通，则每隔一秒再看一次，如果发现ping不通了，就报警。如果什么时候恢复了，就再报告恢复。就是说这个脚本会一直检查服务器状态，ping失败则触发报警，ping恢复则通告恢复。脚本内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">IPADDR=&apos;10.0.0.1&apos;</div><div class="line">INTERVAL=1</div><div class="line"></div><div class="line">while true</div><div class="line">do</div><div class="line">    while ping -c 1 $IPADDR &amp;&gt; /dev/null</div><div class="line">    do</div><div class="line">        sleep $INTERVAL</div><div class="line">    done</div><div class="line"></div><div class="line">    echo &quot;$IPADDR ping error! &quot; 1&gt;&amp;2</div><div class="line"></div><div class="line">    until ping -c 1 $IPADDR &amp;&gt; /dev/null</div><div class="line">    do</div><div class="line">        sleep $INTERVAL</div><div class="line">    done</div><div class="line"></div><div class="line">    echo &quot;$IPADDR ping ok!&quot;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>这里关于输出重定向的知识我就先不讲解了，后续会有别的文章专门针对这个主题做出说明。以上就是if分支结构和while、until循环结构。掌握了这两种结构之后，我们就可以写出几乎所有功能的bash脚本程序了。这两种语法结构的共同特点是，使用list作为“判断条件”，这种“风味”的语法特点是“一切皆表达式”。bash为了使用方便，还给我们提供了另外一些“风味”的语法。下面我们继续看：</p>
<h2 id="case分支结构和for循环结构"><a href="#case分支结构和for循环结构" class="headerlink" title="case分支结构和for循环结构"></a>case分支结构和for循环结构</h2><p>我们之所以把case分支和for循环放在一起讨论，主要是因为它们所判断的不再是“表达式”是否为真，而是去匹配字符串。我们还是通过其语法和例子来理解一下。case分支的语法结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac</div></pre></td></tr></table></figure>
<p>与if语句是以fi标记结束思路相仿，case语句是以esac标记结束。其常见的换行版本是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">case $1 in</div><div class="line">        pattern)</div><div class="line">        list</div><div class="line">        ;;</div><div class="line">        pattern)</div><div class="line">        list</div><div class="line">        ;;</div><div class="line">        pattern)</div><div class="line">        list</div><div class="line">        ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>举几个几个简单的例子，并且它们实际上是一样的：</p>
<p>例1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">case $1 in</div><div class="line">    (zorro)</div><div class="line">    echo &quot;hello zorro!&quot;</div><div class="line">    ;;</div><div class="line">    (jerry)</div><div class="line">    echo &quot;hello jerry!&quot;</div><div class="line">    ;;</div><div class="line">    (*)</div><div class="line">    echo &quot;get out!&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>例2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">case $1 in</div><div class="line">    zorro)</div><div class="line">    echo &quot;hello zorro!&quot;</div><div class="line">    ;;</div><div class="line">    jerry)</div><div class="line">    echo &quot;hello jerry!&quot;</div><div class="line">    ;;</div><div class="line">    *)</div><div class="line">    echo &quot;get out!&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>例3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">case $1 in</div><div class="line">    zorro|jerry)</div><div class="line">    echo &quot;hello $1!&quot;</div><div class="line">    ;;</div><div class="line">    *)</div><div class="line">    echo &quot;get out!&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>这些程序的执行结果都是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./case.sh zorro</div><div class="line">hello zorro!</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./case.sh jerry</div><div class="line">hello jerry!</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./case.sh xxxxxx</div><div class="line">get out!</div></pre></td></tr></table></figure>
<p>这些程序应该不难理解，无非就是几个语法的不一样之处，大家自己可以看到哪些可以省略，哪些不能省略。这里需要介绍一下的有两个概念：</p>
<ul>
<li>$1在脚本中表示传递给脚本命令的第一个参数。关于这个变量以及其相关系列变量的使用，我们会在后续其它文章中介绍。</li>
<li>pattern就是bash中“通配符”的概念。常用的bash通配符包括星号(*)、问号(?)和其它一些字符。相信如果对bash有一定了解的话，对这些符号并不陌生，我们在此简单说明一下。</li>
</ul>
<p>最常见的通配符有三个：</p>
<p>? 表示任意一个字符。这个没什么可说的。</p>
<ul>
<li>表示任意长度任意字符，包括空字符。在bash4.0以上版本中，如果bash环境开启了globstar设置，那么两个连续的**可以用来递归匹配某目录下所有的文件名。我们通过一个实验测试一下：</li>
</ul>
<p>一个目录的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ tree test/</div><div class="line">test/</div><div class="line">├── 1</div><div class="line">├── 2</div><div class="line">├── 3</div><div class="line">├── 4</div><div class="line">├── a</div><div class="line">│   ├── 1</div><div class="line">│   ├── 2</div><div class="line">│   ├── 3</div><div class="line">│   └── 4</div><div class="line">├── a.conf</div><div class="line">├── b</div><div class="line">│   ├── 1</div><div class="line">│   ├── 2</div><div class="line">│   ├── 3</div><div class="line">│   └── 4</div><div class="line">├── b.conf</div><div class="line">├── c</div><div class="line">│   ├── 5</div><div class="line">│   ├── 6</div><div class="line">│   ├── 7</div><div class="line">│   └── 8</div><div class="line">└── d</div><div class="line">    ├── 1.conf</div><div class="line">    └── 2.conf</div><div class="line"></div><div class="line">4 directories, 20 files</div></pre></td></tr></table></figure>
<p>使用通配符进行文件名匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo test/*</div><div class="line">test/1 test/2 test/3 test/4 test/a test/a.conf test/b test/b.conf test/c test/d</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo test/*.conf</div><div class="line">test/a.conf test/b.conf</div></pre></td></tr></table></figure>
<p>这个结果大家应该都熟悉。我们再来看看下面：<br>查看当前globstar状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ shopt globstar</div><div class="line">globstar        off</div></pre></td></tr></table></figure>
<p>打开globstar：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ shopt -s globstar</div><div class="line">[zorro@zorrozou-pc0 bash]$ shopt globstar</div><div class="line">globstar        on</div></pre></td></tr></table></figure>
<p>使用**匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo test/**</div><div class="line">test/ test/1 test/2 test/3 test/4 test/a test/a/1 test/a/2 test/a/3 test/a/4 test/a.conf test/b test/b/1 test/b/2 test/b/3 test/b/4 test/b.conf test/c test/c/5 test/c/6 test/c/7 test/c/8 test/d test/d/1.conf test/d/2.conf</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo test/**/*.conf</div><div class="line">test/a.conf test/b.conf test/d/1.conf test/d/2.conf</div></pre></td></tr></table></figure>
<p>关闭globstart并再次测试**：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ shopt -u globstar</div><div class="line">[zorro@zorrozou-pc0 bash]$ shopt  globstar</div><div class="line">globstar        off</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ echo test/**/*.conf</div><div class="line">test/d/1.conf test/d/2.conf</div><div class="line">[zorro@zorrozou-pc0 bash]$ </div><div class="line">[zorro@zorrozou-pc0 bash]$ echo test/**</div><div class="line">test/1 test/2 test/3 test/4 test/a test/a.conf test/b test/b.conf test/c test/d</div></pre></td></tr></table></figure>
<p>[…] 表示这个范围中的任意一个字符。比如[abcd]，表示a或b或c或d。当然这也可以写成[a-d]。[a-z]表示任意一个小些字母。还是刚才的test目录，我们再来试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls test/[123]</div><div class="line">test/1  test/2  test/3</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls test/[abc]</div><div class="line">test/a:</div><div class="line">1  2  3  4</div><div class="line"></div><div class="line">test/b:</div><div class="line">1  2  3  4</div><div class="line"></div><div class="line">test/c:</div><div class="line">5  6  7  8</div></pre></td></tr></table></figure>
<p>以上就是简单的三个通配符的说明。当然，关于通配符以及shopt命令还有很多相关知识。我们还是会在后续的文章中单独把相关知识点拿出来讲，再这里大家先理解这几个。另外需要强调一点，千万不要把bash的通配符和正则表达式搞混了，它们完全没有关系！</p>
<p>简要理解了pattern的概念之后，我们就可以更加灵活的使用case了，它不仅仅可以匹配一个固定的字符串，还可以利用pattern做到一定程度的模糊匹配。但是无论怎样，case都是去比较字符串是否一样，这跟使用if语句有本质的不同，if是判断表达式。当然，我们在if中使用test命令同样可以做到case的效果，区别仅仅是程序代码多少的区别。还是举个例子说明一下，我们想写一个身份验证程序，大家都知道，一个身份验证程序要判断用户名及其密码是否都匹配某一个字符串，如果两个都匹配，就通过验证，如果有一个不匹配就不能通过验证。分别用if和case来实现这两个验证程序内容如下：</p>
<p>if版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">if [ $1 = &quot;zorro&quot; ] &amp;&amp; [ $2 = &quot;zorro&quot; ]</div><div class="line">then</div><div class="line">    echo &quot;ok&quot;</div><div class="line">elif [ $1$2 = &quot;jerryjerry&quot; ]</div><div class="line">then</div><div class="line">    echo &quot;ok&quot;</div><div class="line">else</div><div class="line">    echo &quot;auth failed!&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>case版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">case $1$2 in</div><div class="line">    zorrozorro|jerryjerry)</div><div class="line">    echo &quot;ok!&quot;</div><div class="line">    ;;</div><div class="line">    *)</div><div class="line">    echo &quot;auth failed!&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>两个程序一对比，直观看起来case版的要少些代码，表达力也更强一些。但是，这两个程序都有bug，如果case版程序给的两个参数是zorro zorro可以报ok。如果是zorroz orro是不是也可以报ok？如果只给一个参数zorrozorro，另一个参数为空，是不是也可以报ok？同样，if版的jerry判断也有类似问题。当你的程序要跟用户或其它程序交互的时候，一定要谨慎仔细的检查输入，一般写程序很大工作量都在做各种异常检查上，尤其是需要跟人交互的时候。我们看似用一个合并字符串变量的技巧，将两个判断给合并成了一个，但是这个技巧却使程序编写出了错误。对于这个现象，我的意见是，如果不是必要，请不要在编程中玩什么“技巧”，重剑无锋，大巧不工。当然，这个bug可以通过如下方式解决：</p>
<p>if版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">if [ $1 = &quot;zorro&quot; ] &amp;&amp; [ $2 = &quot;zorro&quot; ]</div><div class="line">then</div><div class="line">    echo &quot;ok&quot;</div><div class="line">elif [ $1:$2 = &quot;jerry:jerry&quot; ]</div><div class="line">then</div><div class="line">    echo &quot;ok&quot;</div><div class="line">else</div><div class="line">    echo &quot;auth failed!&quot;</div><div class="line">fi</div></pre></td></tr></table></figure>
<p>case版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">case $1x$2 in</div><div class="line">    zorro:zorro|jerry:jerry)</div><div class="line">    echo &quot;ok!&quot;</div><div class="line">    ;;</div><div class="line">    *)</div><div class="line">    echo &quot;auth failed!&quot;</div><div class="line">    ;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>我加的是个:字符，当然，也可以加其他字符，原则是这个字符不要再输入中能出现。我们在其他人写的程序里也经常能看到类似这样的判断处理：</p>
<p>if [ x$1 = x”zorro” ] &amp;&amp; [ x$2 = x”zorro” ]</p>
<p>相信你也能明白为什么要这么处理了。仅对某一个判断来说这似乎没什么必要，但是如果你养成了这样的习惯，那么就能让你避免很多可能出问题的环节。这就是编程经验和编程习惯的重要性。当然，很多人只有“经验”，却也不知道这个经验是怎么来的，那也并不可取。</p>
<h2 id="for循环结构"><a href="#for循环结构" class="headerlink" title="for循环结构"></a>for循环结构</h2><p>bash提供了两种for循环，一种是类似C语言的for循环，另一种是让某变量在一系列字符串中做循环。在此，我们先说后者。其语法结构是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for name [ [ in [ word ... ] ] ; ] do list ; done</div></pre></td></tr></table></figure>
<p>其中name一般是一个变量名，后面的word …是我们要让这个变量分别赋值的字符串列表。这个循环将分别将name变量每次赋值一个word，并执行循环体，直到所有word被遍历之后退出循环。这是一个非常有用的循环结构，其使用频率可能远高于while、until循环。我们来看看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ for i in 1 2 3 4 5;do echo $i;done</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td></tr></table></figure>
<p>再看另外一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ for i in aaa bbb ccc ddd eee;do echo $i;done</div><div class="line">aaa</div><div class="line">bbb</div><div class="line">ccc</div><div class="line">ddd</div><div class="line">eee</div></pre></td></tr></table></figure>
<p>再看一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ for i in /etc/* ;do echo $i;done</div><div class="line">/etc/adjtime</div><div class="line">/etc/adobe</div><div class="line">/etc/appstream.conf</div><div class="line">/etc/arch-release</div><div class="line">/etc/asound.conf</div><div class="line">/etc/avahi</div><div class="line">......</div></pre></td></tr></table></figure>
<p>这种例子举不胜举，可以用for遍历的东西真的很多，大家可以自己发挥想象力。这里要提醒大家注意的是当你学会了“或$()这个符号之后，for的范围就更大了。于是很多然喜欢这样搞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ for i in `ls`;do echo $i;done</div><div class="line">auth_case.sh</div><div class="line">auth_if.sh</div><div class="line">case.sh</div><div class="line">if_1.sh</div><div class="line">ping.sh</div><div class="line">test</div><div class="line">until.sh</div><div class="line">while.sh</div></pre></td></tr></table></figure>
<p>乍看起来这好像跟使用*没啥区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ for i in *;do echo $i;done</div><div class="line">auth_case.sh</div><div class="line">auth_if.sh</div><div class="line">case.sh</div><div class="line">if_1.sh</div><div class="line">ping.sh</div><div class="line">test</div><div class="line">until.sh</div><div class="line">while.sh</div></pre></td></tr></table></figure>
<p>但可惜的是并不总是这样，请对比如下两个测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ for i in `ls /etc`;do echo $i;done</div><div class="line">adjtime</div><div class="line">adobe</div><div class="line">appstream.conf</div><div class="line">arch-release</div><div class="line">asound.conf</div><div class="line">avahi</div><div class="line">bash.bash_logout</div><div class="line">bash.bashrc</div><div class="line">bind.keys</div><div class="line">binfmt.d</div><div class="line">......</div><div class="line"></div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ for i in /etc/*;do echo $i;done</div><div class="line">/etc/adjtime</div><div class="line">/etc/adobe</div><div class="line">/etc/appstream.conf</div><div class="line">/etc/arch-release</div><div class="line">/etc/asound.conf</div><div class="line">/etc/avahi</div><div class="line">/etc/bash.bash_logout</div><div class="line">/etc/bash.bashrc</div><div class="line">/etc/bind.keys</div><div class="line">/etc/binfmt.d</div><div class="line">......</div></pre></td></tr></table></figure>
<p>看到差别了么？</p>
<p>其实这里还会隐含很多其它问题，像ls这样的命令很多时候是设计给人用的，它的很多显示是有特殊设定的，可能并不是纯文本。比如可能包含一些格式化字符，也可能包含可以让终端显示出颜色的标记字符等等。当我们在程序里面使用类似这样的命令的时候要格外小心，说不定什么时候在什么不同环境配置的系统上，你的程序就会有意想不到的异常出现，到时候排查起来非常麻烦。所以这里我们应该尽量避免使用ls这样的命令来做类似的行为，用通配符可能更好。当然，如果你要操作的是多层目录文件的话，那么ls就更不能帮你的忙了，它遇到目录之后显示成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/*</div><div class="line">/etc/adobe:</div><div class="line">mms.cfg</div><div class="line"></div><div class="line">/etc/avahi:</div><div class="line">avahi-autoipd.action  avahi-daemon.conf  avahi-dnsconfd.action  hosts  services</div><div class="line"></div><div class="line">/etc/binfmt.d:</div><div class="line"></div><div class="line">/etc/bluetooth:</div><div class="line">main.conf</div><div class="line"></div><div class="line">/etc/ca-certificates:</div><div class="line">extracted  trust-source</div></pre></td></tr></table></figure>
<p>所以遍历一个目录还是要用刚才说到的**，如果不是bash 4.0之后的版本的话，可以使用find。我推荐用find，因为它更通用。有时候你会发现，使用find之后，绝大多数原来需要写脚本解决的问题可能都用不着了，一个find命令解决很多问题。</p>
<h2 id="select和第二种for循环"><a href="#select和第二种for循环" class="headerlink" title="select和第二种for循环"></a>select和第二种for循环</h2><p>我之所以把这两种语法放到一起讲，主要是这两种语法结构在bash编程中使用的几率可能较小。这里的第二种for循环是相对于上面讲的第一种for循环来说的。实际上这种for循环就是C语言中for循环的翻版，其语义基本一致，区别是括号()变成了双括号(())，循环标记开始和结束也是bash风味的do和done，其语法结构为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (( expr1 ; expr2 ; expr3 )) ; do list ; done</div></pre></td></tr></table></figure>
<p>看一个产生0-99数字的循环例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">for ((count=0;count&lt;100;count++))</div><div class="line">do</div><div class="line">    echo $count</div><div class="line">done</div></pre></td></tr></table></figure>
<p>我们可以理解为，bash为了对数学运算作为条件的循环方便我们使用，专门扩展了一个for循环来给我们使用。跟C语言一样，这个循环本质上也只是一个while循环，只是把变量初始化，变量比较和循环体中的变量操作给放到了同一个(())语句中。这里不再废话。</p>
<p>最后是select循环，实际上select提供给了我们一个构建交互式菜单程序的方式，如果没有select的话，我们在shell中写交互的菜单程序是比较麻烦的。它的语法结构是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select name [ in word ] ; do list ; done</div></pre></td></tr></table></figure>
<p>还是来看看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">select i in a b c d</div><div class="line">do</div><div class="line">    echo $i</div><div class="line">done</div></pre></td></tr></table></figure>
<p>这个程序执行的效果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./select.sh </div><div class="line">1) a</div><div class="line">2) b</div><div class="line">3) c</div><div class="line">4) d</div><div class="line">#?</div></pre></td></tr></table></figure>
<p>你会发现select给你构造了一个交互菜单，索引为1，2，3，4。对应的名字就是程序中的a，b，c，d。之后我们就可以在后面输入相应的数字索引，选择要echo的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./select.sh </div><div class="line">1) a</div><div class="line">2) b</div><div class="line">3) c</div><div class="line">4) d</div><div class="line">#? 1</div><div class="line">a</div><div class="line">#? 2</div><div class="line">b</div><div class="line">#? 3</div><div class="line">c</div><div class="line">#? 4</div><div class="line">d</div><div class="line">#? 6</div><div class="line"></div><div class="line">#? </div><div class="line">1) a</div><div class="line">2) b</div><div class="line">3) c</div><div class="line">4) d</div><div class="line">#? </div><div class="line">1) a</div><div class="line">2) b</div><div class="line">3) c</div><div class="line">4) d</div><div class="line">#?</div></pre></td></tr></table></figure>
<p>如果输入的不是菜单描述的范围就会echo一个空行，如果直接输入回车，就会再显示一遍菜单本身。当然我们会发现这样一个菜单程序似乎没有什么意义，实际程序中，select大多数情况是跟case配合使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">select i in a b c d</div><div class="line">do</div><div class="line">    case $i in</div><div class="line">        a)</div><div class="line">        echo &quot;Your choice is a&quot;</div><div class="line">        ;;</div><div class="line">        b)</div><div class="line">        echo &quot;Your choice is b&quot;</div><div class="line">        ;;</div><div class="line">        c)</div><div class="line">        echo &quot;Your choice is c&quot;</div><div class="line">        ;;</div><div class="line">        d)</div><div class="line">        echo &quot;Your choice is d&quot;</div><div class="line">        ;;</div><div class="line">        *)</div><div class="line">        echo &quot;Wrong choice! exit!&quot;</div><div class="line">        exit</div><div class="line">        ;;</div><div class="line">    esac</div><div class="line">done</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./select.sh </div><div class="line">1) a</div><div class="line">2) b</div><div class="line">3) c</div><div class="line">4) d</div><div class="line">#? 1</div><div class="line">Your choice is a</div><div class="line">#? 2</div><div class="line">Your choice is b</div><div class="line">#? 3</div><div class="line">Your choice is c</div><div class="line">#? 4</div><div class="line">Your choice is d</div><div class="line">#? 5</div><div class="line">Wrong choice! exit!</div></pre></td></tr></table></figure>
<p>这就是select的常见用法。</p>
<h2 id="continue和break"><a href="#continue和break" class="headerlink" title="continue和break"></a>continue和break</h2><p>对于bash的实现来说，continue和break实际上并不是语法的关键字，而是被作为内建命令来实现的。不过我们从习惯上依然把它们看作是bash的语法。在bash中，break和continue可以用来跳出和金星下一次for，while，until和select循环。<br>最后</p>
<p>我们在本文中介绍了bash编程的常用语法结构：if、while、until、case、两种for和select。我们在详细分析它们语法的特点的过程中，也简单说明了使用时需要注意的问题。希望这些知识和经验对大家以后在bash编程上有帮助。</p>
<p>通过bash编程语法的入门，我们也能发现，bash编程是一个上手容易，但是精通困难的编程语言。任何人想要写个简单的脚本，掌握几个语法结构和几个shell命令基本就可以干活了，但是想写出高质量的代码确没那么容易。通过语法的入门，我们可以管中窥豹的发现，讲述的过程中有无数个可以深入探讨的细节知识点，比如通配符、正则表达式、bash的特殊字符、bash的特殊属性和很多shell命令的使用。我们的后续文章会给大家分块整理这些知识点，如果你有兴趣，请持续关注。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/11/php-glob/" title="php glob" itemprop="url">php glob</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-11T06:13:00.000Z" itemprop="datePublished"> 发表于 2016-05-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="php查找符合某些规则的文件"><a href="#php查找符合某些规则的文件" class="headerlink" title="php查找符合某些规则的文件"></a>php查找符合某些规则的文件</h2><p>通常实现查找目录下某些规则的文件，用shell实现起来很容易，但是php呢,个人想到的是遍历目录下所有文件并再用正则筛选.<br>然而php有现成的函数已经为我们做好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">说明</div><div class="line">array glob ( string $pattern [, int $flags = 0 ] )</div><div class="line"></div><div class="line">glob() 函数依照 libc glob() 函数使用的规则寻找所有与 pattern 匹配的文件路径，类似于一般 shells 所用的规则一样。不进行缩写扩展或参数替代。</div><div class="line">参数</div><div class="line"></div><div class="line">pattern</div><div class="line"></div><div class="line">    The pattern. No tilde expansion or parameter substitution is done.</div><div class="line">flags</div><div class="line"></div><div class="line">    有效标记有：</div><div class="line"></div><div class="line">        GLOB_MARK - 在每个返回的项目中加一个斜线</div><div class="line">        GLOB_NOSORT - 按照文件在目录中出现的原始顺序返回（不排序）</div><div class="line">        GLOB_NOCHECK - 如果没有文件匹配则返回用于搜索的模式</div><div class="line">        GLOB_NOESCAPE - 反斜线不转义元字符</div><div class="line">        GLOB_BRACE - 扩充 &#123;a,b,c&#125; 来匹配 &apos;a&apos;，&apos;b&apos; 或 &apos;c&apos;</div><div class="line">        GLOB_ONLYDIR - 仅返回与模式匹配的目录项</div><div class="line">        GLOB_ERR - 停止并读取错误信息（比如说不可读的目录），默认的情况下忽略所有错误</div><div class="line"></div><div class="line">返回值</div><div class="line"></div><div class="line">返回一个包含有匹配文件／目录的数组。如果出错返回 FALSE。</div><div class="line"></div><div class="line">    Note:</div><div class="line"></div><div class="line">    On some systems it is impossible to distinguish between empty match and an error.</div></pre></td></tr></table></figure>
<p>比如查找某目录下的txt文件并显示其大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?php</div><div class="line">foreach (glob(&quot;*.txt&quot;) as $filename) &#123;</div><div class="line">    echo &quot;$filename size &quot; . filesize($filename) . &quot;\n&quot;;</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/php/">php</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/php/">php</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/09/php-curl-file-get-contents比较/" title="php curl file_get_contents比较" itemprop="url">php curl file_get_contents比较</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-09T12:32:00.000Z" itemprop="datePublished"> 发表于 2016-05-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近发布系统出现了一些速度问题，而且时好时坏，网络非常不稳定，查了一下，发现代码里出现很多file_get_contents函数</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>写两个简单的例子吧<br>curl </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$i= 0;</div><div class="line">do&#123;</div><div class="line">    $t1 = microtime();</div><div class="line">    $url = &quot;http://www.anjuke.com&quot;;</div><div class="line">    file_get_contents($url);</div><div class="line">    $t2 = microtime();</div><div class="line">    echo (($t2-$t1)&lt;0?($t2-$t1)+1:($t2-$t1)).PHP_EOL;</div><div class="line">&#125;while($i++&lt;2);</div></pre></td></tr></table></figure>
<p>file_get_contents</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$i= 0;</div><div class="line">do&#123;</div><div class="line">    $t1 = microtime();</div><div class="line">    $url = &quot;http://www.anjuke.com&quot;;</div><div class="line">    file_get_contents($url);</div><div class="line">    $t2 = microtime();</div><div class="line">    echo (($t2-$t1)&lt;0?($t2-$t1)+1:($t2-$t1)).PHP_EOL;</div><div class="line">&#125;while($i++&lt;20);</div></pre></td></tr></table></figure>
<p>测试了一下，速度相差一个数量级,为何相差如此悬殊，查了些资料，原来file_get_contents会刷新dns缓存。<br>使用strace 追踪,发现其会读取/etc/hosts 和/etc/resolv.conf 文件,找到dns server,而curl不会。</p>
<p>此外，curl相对自由一些，file_get_contents不支持post请求等等</p>
<p>相关参考 :</p>
<p><a href="http://www.nowamagic.net/academy/detail/12220248" target="_blank" rel="external">fsockopen/curl/file_get_contents效率比较</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/php/">php</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/php/">php</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/04/mysql/" title="MySQL索引背后的数据结构及算法原理" itemprop="url">MySQL索引背后的数据结构及算法原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-04T02:48:37.000Z" itemprop="datePublished"> 发表于 2016-05-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>文章转自<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a><br>一些代码和图片没有原文做的好，如果原文没有失效的话请选择访问原文链接</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p>
<p>文章主要内容分为三个部分。</p>
<p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p>
<p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p>
<p>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。</p>
<h1 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h1><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<br>看一个例子：<br><img src="http://githubforericwang.qiniudn.com/hexo/eric/1.png" alt="图一"><br>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)<br>Olog2n<br>的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
<h2 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<ul>
<li><p>d为大于1的一个正整数，称为B-Tree的度。</p>
</li>
<li><p>h为一个正整数，称为B-Tree的高度。</p>
</li>
<li><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
</li>
<li><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
</li>
<li><p>所有叶节点具有相同的深度，等于树高h。</p>
</li>
<li><p>key和指针互相间隔，节点两端是指针。</p>
</li>
<li><p>一个节点中的key从左到右非递减排列。</p>
</li>
<li><p>所有节点组成树结构。</p>
</li>
<li><p>每个指针要么为null，要么指向另外一个节点。</p>
</li>
<li><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</p>
</li>
<li><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p>
</li>
<li><p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)</p>
</li>
</ul>
<p>图2是一个d=2的B-Tree示意图。<br><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/2.png" alt="图2"></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BTree_Search(node, key) &#123;</div><div class="line">    if(node == null) return null;</div><div class="line">    foreach(node.key)</div><div class="line">    &#123;</div><div class="line">        if(node.key[i] == key) return node.data[i];</div><div class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</div><div class="line">    &#125;</div><div class="line">    return BTree_Search(point[i+1]-&gt;node);</div><div class="line">&#125;</div><div class="line">data = BTree_Search(root, my_key);</div></pre></td></tr></table></figure></p>
<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。<br>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p>
<h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>每个节点的指针上限为2d而不是2d+1。</p>
<p>内节点不存储data，只存储key；叶子节点不存储指针。</p>
<p>图3是一个简单的B+Tree示意。</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/3.png" alt="图三"></p>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h2 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h2><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/4.png" alt="图4"></p>
<p>如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。<br>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p>
<h1 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h1><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h2 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h2><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/5.png" alt="图5"></p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>图6是磁盘的整体结构示意图。</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/6.png" alt="图6"></p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>图7是磁盘结构的示意图。</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/7.png" alt="图7"></p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>到这里终于可以分析B-/+Tree索引的性能了。</p>
<p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：<br>dmax=floor(pagesize/(keysize+datasize+pointsize))</p>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h1 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h1><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/8.png" alt="图8"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/9.png" alt="图9"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/10.png" alt="图10"></p>
<p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/11.png" alt="图11"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<p>下一章将具体讨论这些与索引有关的优化策略。</p>
<h1 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h1><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑</p>
<h2 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h2><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/12.png" alt=""></p>
<p>MySQL官方文档中关于此数据库的页面为<a href="http://dev.mysql.com/doc/employee/en/employee.html。" target="_blank" rel="external">http://dev.mysql.com/doc/employee/en/employee.html。</a><br>里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</p>
<h2 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h2><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p>
<p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<a1, a2,="" …,="" an="">，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</a1,></p>
<p>以employees.titles表为例，下面先查看其上都有哪些索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SHOW INDEX FROM employees.titles;</div><div class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</div><div class="line">| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |</div><div class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</div><div class="line">| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |</div><div class="line">| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |</div><div class="line">| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |</div><div class="line">| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |</div><div class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</div></pre></td></tr></table></figure></p>
<p>从结果中可以到titles表的主索引为<emp_no, title,="" from_date="">，还有一个辅助索引<emp_no>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</emp_no></emp_no,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE employees.titles DROP INDEX emp_no;</div><div class="line">这样就可以专心分析索引PRIMARY的行为了。</div></pre></td></tr></table></figure>
<p>情况一：全列匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title=&apos;Senior Engineer&apos; AND from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div></pre></td></tr></table></figure>
<p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date=&apos;1986-06-26&apos; AND emp_no=&apos;10001&apos; AND title=&apos;Senior Engineer&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div></pre></td></tr></table></figure>
<p>效果是一样的。</p>
<p>情况二：最左前缀匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos;;</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</div></pre></td></tr></table></figure>
<p>当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或<emp_no, title="">，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</emp_no,></emp_no></p>
<p>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div></pre></td></tr></table></figure>
<p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<emp_no, from_date="">，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</emp_no,></p>
<p>首先我们看下title一共有几种不同的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SELECT DISTINCT(title) FROM employees.titles;</div><div class="line">+--------------------+</div><div class="line">| title              |</div><div class="line">+--------------------+</div><div class="line">| Senior Engineer    |</div><div class="line">| Staff              |</div><div class="line">| Engineer           |</div><div class="line">| Senior Staff       |</div><div class="line">| Assistant Engineer |</div><div class="line">| Technique Leader   |</div><div class="line">| Manager            |</div><div class="line">+--------------------+</div></pre></td></tr></table></figure>
<p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles</div><div class="line">WHERE emp_no=&apos;10001&apos;</div><div class="line">AND title IN (&apos;Senior Engineer&apos;, &apos;Staff&apos;, &apos;Engineer&apos;, &apos;Senior Staff&apos;, &apos;Assistant Engineer&apos;, &apos;Technique Leader&apos;, &apos;Manager&apos;)</div><div class="line">AND from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SHOW PROFILES;</div><div class="line">+----------+------------+-------------------------------------------------------------------------------+</div><div class="line">| Query_ID | Duration   | Query                                                                         |</div><div class="line">+----------+------------+-------------------------------------------------------------------------------+</div><div class="line">|       10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND from_date=&apos;1986-06-26&apos;|</div><div class="line">|       11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title IN ...          |</div><div class="line">+----------+------------+-------------------------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p>
<p>情况四：查询条件没有指定索引第一列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>由于不是最左前缀，索引这样的查询显然用不到索引。</p>
<p>情况五：匹配某列的前缀字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title LIKE &apos;Senior%&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>此时可以用到索引，但是如果通配符不是只出现在末尾，则无法使用索引。（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p>
<p>情况六：范围查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; &apos;10010&apos; and title=&apos;Senior Engineer&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">EXPLAIN SELECT * FROM employees.titles</div><div class="line">WHERE emp_no &lt; &apos;10010&apos;</div><div class="line">AND title=&apos;Senior Engineer&apos;</div><div class="line">AND from_date BETWEEN &apos;1986-01-01&apos; AND &apos;1986-12-31&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles</div><div class="line">WHERE emp_no BETWEEN &apos;10001&apos; AND &apos;10010&apos;</div><div class="line">AND title=&apos;Senior Engineer&apos;</div><div class="line">AND from_date BETWEEN &apos;1986-01-01&apos; AND &apos;1986-12-31&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p>
<p>情况七：查询条件中含有函数或表达式。</p>
<p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND left(title, 6)=&apos;Senior&apos;;</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div></pre></td></tr></table></figure>
<p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=&apos;10000&apos;;</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p>
<h1 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h1><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Index Selectivity = Cardinality / #T</div></pre></td></tr></table></figure>
<p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;</div><div class="line">+-------------+</div><div class="line">| Selectivity |</div><div class="line">+-------------+</div><div class="line">|      0.0000 |</div><div class="line">+-------------+</div></pre></td></tr></table></figure>
<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p>从图12可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：</emp_no></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.employees WHERE first_name=&apos;Eric&apos; AND last_name=&apos;Anido&apos;;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或<first_name, last_name="">，看下两个索引的选择性：</first_name,></first_name></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees;</div><div class="line">+-------------+</div><div class="line">| Selectivity |</div><div class="line">+-------------+</div><div class="line">|      0.0042 |</div><div class="line">+-------------+</div><div class="line">SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees;</div><div class="line">+-------------+</div><div class="line">| Selectivity |</div><div class="line">+-------------+</div><div class="line">|      0.9313 |</div><div class="line">+-------------+</div></pre></td></tr></table></figure>
<p><first_name>显然选择性太低，<first_name, last_name="">选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如<first_name, left(last_name,="" 3)="">，看看其选择性：</first_name,></first_name,></first_name></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;</div><div class="line">+-------------+</div><div class="line">| Selectivity |</div><div class="line">+-------------+</div><div class="line">|      0.7879 |</div><div class="line">+-------------+</div></pre></td></tr></table></figure>
<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;</div><div class="line">+-------------+</div><div class="line">| Selectivity |</div><div class="line">+-------------+</div><div class="line">|      0.9007 |</div><div class="line">+-------------+</div></pre></td></tr></table></figure>
<p>这时选择性已经很理想了，而这个索引的长度只有18，比<first_name, last_name="">短了接近一半，我们把这个前缀索引 建上：</first_name,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE employees.employees</div><div class="line">ADD INDEX `first_name_last_name4` (first_name, last_name(4));</div><div class="line">此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</div><div class="line"></div><div class="line">SHOW PROFILES;</div><div class="line">+----------+------------+---------------------------------------------------------------------------------+</div><div class="line">| Query_ID | Duration   | Query                                                                           |</div><div class="line">+----------+------------+---------------------------------------------------------------------------------+</div><div class="line">|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name=&apos;Eric&apos; AND last_name=&apos;Anido&apos; |</div><div class="line">|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name=&apos;Eric&apos; AND last_name=&apos;Anido&apos; |</div><div class="line">+----------+------------+---------------------------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<p>InnoDB的主键选择与插入优化</p>
<p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/13.png" alt="图13"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><img src="http://7o52ek.com1.z0.glb.clouddn.com/hexo/eric/14.png" alt="图14"></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。</p>
<p>其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。</p>
<p>另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010</p>
<p>[2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006</p>
<p>[3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011</p>
<p>[4] D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979</p>
<p>[5] Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387</p>
<p>[6] MySQL5.1参考手册 - <a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/23/ps/" title="linux ps 的几个tips" itemprop="url">linux ps 的几个tips</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-04-23T15:47:00.000Z" itemprop="datePublished"> 发表于 2016-04-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>1.有时候查看某些运行中的进程时常常这样(比如nginx)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ ps aux |grep nginx</div><div class="line">root            13617   0.0  0.0  2463900    448   ??  Ss   11:48下午   0:00.00 nginx: master process nginx</div><div class="line">eric            13624   0.0  0.0  2434840    744 s001  R+   11:48下午   0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn nginx</div><div class="line">eric            13618   0.0  0.0  2464120   1000   ??  S    11:48下午   0:00.00 nginx: worker process</div></pre></td></tr></table></figure></p>
<p>问题就是，我想对这些pid做些操作，但是会多出来一个ps进程产生的一行，一直以来也不知道如何去掉这行，反正也不碍事。前些天看到一篇微博里给出了方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ ps aux |grep \[n]ginx</div><div class="line">eric            13618   0.0  0.0  2464120   1000   ??  S    11:48下午   0:00.00 nginx: worker process</div><div class="line">root            13617   0.0  0.0  2463900    448   ??  Ss   11:48下午   0:00.00 nginx: master process nginx</div><div class="line">➜  ~</div></pre></td></tr></table></figure></p>
<p>2.有时候需要展示进程之间的父子关系，虽然有父进程的pid，但是并不直观，可以用<code>ps aux --forest</code><br>3.批量杀掉进程,可以借助xargs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux |grep \[n]ginx |awk &apos;&#123;print $2&#125;&apos; |xargs sudo kill -9</div></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/23/memcache-超详细介绍/" title="memcache 超详细介绍" itemprop="url">memcache 超详细介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-04-23T15:43:10.000Z" itemprop="datePublished"> 发表于 2016-04-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="MemCache是什么"><a href="#MemCache是什么" class="headerlink" title="MemCache是什么"></a>MemCache是什么</h3><p><a href="http://memcached.org/" target="_blank" rel="external">MemCache</a>是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统，用于动态Web应用以减轻数据库的负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高了网站访问的速度。MemCaChe是一个存储键值对的HashMap，在内存中对任意的数据（比如字符串、对象等）所使用的key-value存储，数据可以来自数据库调用、API调用，或者页面渲染的结果。MemCache设计理念就是小而强大，它简单的设计促进了快速部署、易于开发并解决面对大规模的数据缓存的许多难题，而所开放的API使得MemCache能用于Java、C/C++/C#、Perl、Python、PHP、Ruby等大部分流行的程序语言。</p>
<h3 id="Memcache-和Memcached"><a href="#Memcache-和Memcached" class="headerlink" title="Memcache 和Memcached"></a>Memcache 和Memcached</h3><ul>
<li><p>MemCache是项目的名称</p>
</li>
<li><p>MemCached是MemCache服务器端可以执行文件的名称</p>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>无容灾考虑，纯内存缓存，重启后所有数据丢失。存取数据比硬盘快，当内存达到上限后，通过LRU算法自动删除缓存。</li>
<li>基于libevent开发。将Linux的epoll、BSD类操作系统的kqueue(多路复用io模型)等事件处理功能封装成统一的接口,因此memcached在多种操作系统上都可以发挥较好的性能，即使服务器的连接数增加，也能发挥O(1)的性能(<a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">C10k问题</a>)</li>
<li>协议基于文本行，直接通过telnet在memcached服务器上可进行存取数据操作</li>
<li>分布式，memcache算不上是一个真正的分布式系统，因为各个memcached之间并不会“感知“，不会互相通信。分布式部署取决于memcache客户端。</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p>前面说到memcached服务之间并不能互相通信，所以对服务的“选择”落在了客户端上，所以路由算法决定了客户端对哪台memcached进行数据存取。<br>先来看一个简单的路由算法</p>
<h4 id="余数算法"><a href="#余数算法" class="headerlink" title="余数算法"></a>余数算法</h4><p>比方说，字符串str对应的HashCode是50、服务器的数目是3，取余数得到2，str对应节点Node2，所以路由算法把str路由到Node2服务器上。由于HashCode随机性比较强，所以使用余数Hash路由算法就可以保证缓存数据在整个MemCache服务器集群中有比较均衡的分布。</p>
<p>如果不考虑服务器集群的伸缩性(集群中新加入节点或者某节点down掉)，那么余数Hash算法几乎可以满足绝大多数的缓存路由需求。</p>
<p>就假设MemCache服务器集群由3台变为4台，更改服务器列表，仍然使用余数Hash，50对4的余数是2，对应Node2，但是str原来是存在Node1上的，这就导致了缓存没有命中。如果这么说不够明白，那么不妨举个例子，原来有HashCode为0~19的20个数据，那么：</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/memcache/1.png" alt="原始hash"></p>
<p>现在我扩容到4台，加粗标红的表示命中：</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/memcache/2.png" alt="扩容后"></p>
<p>如果我扩容到20+的台数，只有前三个HashCode对应的Key是命中的，也就是15%。当然这只是个简单例子，现实情况肯定比这个复杂得多，不过足以说明，使用余数Hash的路由算法，在扩容的时候会造成大量的数据无法正确命中（其实不仅仅是无法命中，那些大量的无法命中的数据还在原缓存中在被移除前占据着内存）。这个结果显然是无法接受的，在网站业务中，大部分的业务数据度操作请求上事实上是通过缓存获取的，只有少量读操作会访问数据库，因此数据库的负载能力是以有缓存为前提而设计的。当大部分被缓存了的数据因为服务器扩容而不能正确读取时，这些数据访问的压力就落在了数据库的身上，这将大大超过数据库的负载能力，严重的可能会导致数据库宕机。</p>
<h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><p>一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到缓存服务器的Hash映射</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/memcache/3.png" alt="一致性hash"></p>
<p>具体算法过程为：先构造一个长度为2^32 的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 2^32 -1]）将缓存服务器节点放置在这个Hash环上，然后根据需要缓存的数据的Key值计算得到其Hash值（其分布也为[0, 2^32 -1]），然后在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。</p>
<p>就如同图上所示，三个Node点分别位于Hash环上的三个位置，然后Key值根据其HashCode，在Hash环上有一个固定位置，位置固定下之后，Key就会顺时针去寻找离它最近的一个Node，把数据存储在这个Node的MemCache服务器中。使用Hash环如果加了一个节点会怎么样，看一下：</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/memcache/4.png" alt="新增节点后"></p>
<p>加了一个Node4节点，只影响到了一个Key值的数据，本来这个Key值应该是在Node1服务器上的，现在要去Node4了。采用一致性Hash算法，的确也会影响到整个集群，但是影响的只是加粗的那一段而已，相比余数Hash算法影响了远超一半的影响率，这种影响要小得多。更重要的是，集群中缓存服务器节点越多，增加节点带来的影响越小，很好理解。换句话说，随着集群规模的增大，继续命中原有缓存数据的概率会越来越大，虽然仍然有小部分数据缓存在服务器中不能被读到，但是这个比例足够小，即使访问数据库，也不会对数据库造成致命的负载压力。</p>
<p>至于具体应用，这个长度为2^32 的一致性Hash环通常使用二叉查找树实现。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>前面说到memcache是内存缓存，不会持久化数据，而且也会受到机器位数的限制，32位最多只有2G，64位可以认为没有上限。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>下面说下内存分配，传统的内存管理方式是，使用完通过malloc分配的内存后通过free来回收内存，这种方式容易产生内存碎片并降低操作系统对内存的管理效率，所以memcache采用的是固定空间分配，MemCache的这种内存分配的方式称为allocator。</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/memcache/5.png" alt="内存分配方式"></p>
<p>这张图片里面涉及了slab_class、slab、page、chunk四个概念，它们之间的关系是：</p>
<p>＊ MemCache将内存空间分为一组slab</p>
<p>＊ 每个slab下又有若干个page，每个page默认是1M，如果一个slab占用100M内存的话，那么这个slab下应该有100个page，page一旦分配，就不会被回收</p>
<p>＊ 每个page里面包含一组chunk，chunk是真正存放数据的地方，同一个slab里面的chunk的大小是固定的</p>
<p>＊ 有相同大小chunk的slab被组织在一起，称为slab_class</p>
<p>slab的数量是有限的，几个、十几个或者几十个，这个和启动参数的配置相关。</p>
<p>MemCache中的item存放的地方是由item的大小决定的，item总是会被存放到与chunk大小最接近的一个slab中，比如slab[1]的chunk大小为80字节、slab[2]的chunk大小为100字节、slab[3]的chunk大小为128字节（相邻slab内的chunk基本以1.25为比例进行增长，MemCache启动时可以用-f指定这个比例），那么过来一个88字节的item，这个item将被放到2号slab中。放slab的时候，首先slab要申请内存，申请内存是以page为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的page被分配给该slab。申请到page后，slab会将这个page的内存按chunk的大小进行切分，这样就变成了一个chunk数组，最后从这个chunk数组中选择一个用于存储数据。</p>
<p>如果这个slab中没有chunk可以分配了怎么办，如果MemCache启动没有追加-M（禁止LRU，这种情况下内存不够会报Out Of Memory错误），那么MemCache会把这个slab中最近最少使用的chunk中的数据清理掉，然后放上最新的数据。<br>这种内存分配方式的特点避免了管理内存碎片问题，同时也带来了内存浪费的问题，如88字节的item分配在128字节（紧接着大的用）的chunk中，就损失了40字节。</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>Memcached的缓存策略是LRU（最近最少使用）加上延迟删除策略</p>
<p>延迟删除是指memcache并不会监视和清理过期数据，而是在客户端get时检查。比如设置某个key存活30s，到了30s后，memcache并不会主动清理它，而是有get请求发现它后才会设置为过期方便以后优先利用，还有一种情况就是lru。<br>删除操作只会将chunk置为删除状态，这样下次申请的时候可以优先利用。<br>flush操作只会使所有的item失效。<br>这种删除方式，可以提高memcache的效率，因为不必每时每刻检查过期item,从而提高CPU工作效率。<br>LRU只是针对slab内的，并不是全局的，因为不同的slab的chunk不同。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="使用telnet操作memcache"><a href="#使用telnet操作memcache" class="headerlink" title="使用telnet操作memcache"></a>使用telnet操作memcache</h3><ul>
<li>set 和 get</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  ~ telnet localhost 11211</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is &apos;^]&apos;.</div><div class="line">set foo 0 0 6</div><div class="line">123456</div><div class="line">STORED</div><div class="line">get foo</div><div class="line">VALUE foo 0 6</div><div class="line">123456</div><div class="line">END</div></pre></td></tr></table></figure>
<ul>
<li>查看memcache状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">➜  ~ telnet localhost 11211</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is &apos;^]&apos;.</div><div class="line">stats</div><div class="line">STAT pid 1</div><div class="line">STAT uptime 275</div><div class="line">STAT time 1463557642</div><div class="line">STAT version 1.4.25</div><div class="line">STAT libevent 2.0.21-stable</div><div class="line">STAT pointer_size 64</div><div class="line">...</div><div class="line">STAT evictions 0</div><div class="line">STAT reclaimed 0</div><div class="line">STAT crawler_reclaimed 0</div><div class="line">STAT crawler_items_checked 0</div><div class="line">STAT lrutail_reflocked 0</div><div class="line">END</div></pre></td></tr></table></figure>
<ul>
<li>查看各个slab使用状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">➜  ~ telnet localhost 11211</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is &apos;^]&apos;.</div><div class="line">stats slabs</div><div class="line">STAT 1:chunk_size 96</div><div class="line">STAT 1:chunks_per_page 10922</div><div class="line">STAT 1:total_pages 1</div><div class="line">STAT 1:total_chunks 10922</div><div class="line">STAT 1:used_chunks 1</div><div class="line">STAT 1:free_chunks 10921</div><div class="line">STAT 1:free_chunks_end 0</div><div class="line">STAT 1:mem_requested 74</div><div class="line">STAT 1:get_hits 1</div><div class="line">STAT 1:cmd_set 1</div><div class="line">STAT 1:delete_hits 0</div><div class="line">STAT 1:incr_hits 0</div><div class="line">STAT 1:decr_hits 0</div><div class="line">STAT 1:cas_hits 0</div><div class="line">STAT 1:cas_badval 0</div><div class="line">STAT 1:touch_hits 0</div><div class="line">STAT active_slabs 1</div><div class="line">STAT total_malloced 1048512</div><div class="line">END</div></pre></td></tr></table></figure>
<ul>
<li>简易监控<br>telnet是一个交互的工具，并不适合在监控脚本中使用，可以用netcat</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">➜  ~ (echo stats;sleep 1)|nc 127.0.0.1 11211</div><div class="line">STAT pid 1</div><div class="line">STAT uptime 1995</div><div class="line">STAT time 1463559362</div><div class="line">STAT version 1.4.25</div><div class="line">STAT libevent 2.0.21-stable</div><div class="line">STAT pointer_size 64</div><div class="line">STAT rusage_user 0.048000</div><div class="line">STAT rusage_system 0.048000</div><div class="line">....</div></pre></td></tr></table></figure>
<h3 id="php中的一些应用"><a href="#php中的一些应用" class="headerlink" title="php中的一些应用"></a>php中的一些应用</h3><p>memcache常常作为数据缓存，来缓解mysql的压力。<br>当item不存在时，memcache会返回false，可以根据memcache的返回结果。<br>注意判断只能使用 ===<br>当设置一个key为false时，memcache会返回一个空字符串。</p>
<ul>
<li>一个简单的缓存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function getFoo($id,$cleanCache)&#123;</div><div class="line">	$memcache =  CacheFactory:getInstance()-&gt;getMemcache(&quot;&quot;);</div><div class="line">    $prefix = &quot;foo_&quot;;</div><div class="line">	$key = $prefix.$id;</div><div class="line">	$value = $memcache-&gt;get($key);</div><div class="line">	if($value === false || $cleanCache)&#123;</div><div class="line">		$value = DaoFactory::get();</div><div class="line">		...</div><div class="line">		memcache-&gt;set($key,$value,0,self::$expireTime);</div><div class="line">	&#125;</div><div class="line">	return $value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>分布式会话管理</li>
</ul>
<p>登陆信息等。</p>
<ul>
<li>memcache cas<br>memcache的每一个命令都是原子操作的,比如get，set，但是针对同一个key的多次get，set请求并不是原子的，是串行化的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$m = new Memcached();</div><div class="line">$m-&gt;addServer(&apos;localhost&apos;, 11211);</div><div class="line"></div><div class="line">do &#123;</div><div class="line">    /* 获取ip列表以及它的标记 */</div><div class="line">    $ips = $m-&gt;get(&apos;ip_block&apos;, null, $cas);</div><div class="line">    /* 如果列表不存在， 创建并进行一个原子添加（如果其他客户端已经添加， 这里就返回false）*/</div><div class="line">    if ($m-&gt;getResultCode() == Memcached::RES_NOTFOUND) &#123;</div><div class="line">        $ips = array($_SERVER[&apos;REMOTE_ADDR&apos;]);</div><div class="line">        $m-&gt;add(&apos;ip_block&apos;, $ips);</div><div class="line">    /* 其他情况下，添加ip到列表中， 并以cas方式去存储， 这样当其他客户端修改过， 则返回false */</div><div class="line">    &#125; else &#123; </div><div class="line">        $ips[] = $_SERVER[&apos;REMOTE_ADDR&apos;];</div><div class="line">        $m-&gt;cas($cas, &apos;ip_block&apos;, $ips);</div><div class="line">    &#125;   </div><div class="line">&#125; while ($m-&gt;getResultCode() != Memcached::RES_SUCCESS);</div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>有兴趣的可以看一下这篇文章:<a href="http://blog.csdn.net/jiangbo_hit/article/details/6211704" target="_blank" rel="external">memcached 原子性操作 CAS模式</a></p>
<ul>
<li>socket 操作memcache<br>一般都不会这么用，除非没有安装memcache扩展</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//connect</div><div class="line">$socket = fsockopen(&apos;10.207.26.234&apos;,11211);</div><div class="line"></div><div class="line">//set</div><div class="line">fwrite($socket,&quot;set a 0 0 1\r\n1\r\n&quot;);</div><div class="line">$response = fgets($socket);</div><div class="line">echo &quot;&lt;pre&gt;&quot;;print_r($response);</div><div class="line">//get</div><div class="line">fwrite($socket,&quot;get a\r\n&quot;);</div><div class="line">$response = fread($socket,1024);</div><div class="line">echo &quot;&lt;pre&gt;&quot;;print_r($response);</div></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>适用的场景</p>
<ul>
<li>对于mysql读&gt;&gt;写的场景，memcached可以显著地提高运行效率</li>
<li>一些很小但是频繁访问的文件</li>
<li>session数据</li>
<li>计算量很大，可以用memcache缓存结果</li>
</ul>
<p>不适用的场景</p>
<ul>
<li>需要获取所有key</li>
<li>key的长度超过250字符</li>
<li>item过大</li>
<li>实时性要求高的场景</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>安全</li>
<li>其他缓存系统，redis，mongodb，hbase等等</li>
<li>缓存一致性问题</li>
<li>缓存雪崩</li>
<li>缓存预热</li>
<li>缓存无底洞</li>
<li>(twemproxy)nutcraker</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/xrq730/p/4948707.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">MemCache超详细解读</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/21/other_03/" title="无题" itemprop="url">无题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-04-21T13:31:21.000Z" itemprop="datePublished"> 发表于 2016-04-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>年后没怎么写博客，老大不小了，得考虑未来的去处了，择一城终老，上海的限购政策也是坑死单身狗，身边也有朋友渐渐离开，一方面也是因为离家远。最终做了个决定，离开上海，3月离职，国内转了半个月，一路吃到北京。开始找工作，面了5家拿了3家offer，拿到了链家offer，很想去链家和牛人们一起交流学习，但是经济原因和路程原因，放弃了链家。也不想去什么创业公司，图个稳定，好好的呆满5年</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/2/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/C/" style="font-size: 15.71px;">C</a> <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/arch/" style="font-size: 10px;">arch</a> <a href="/tags/bower/" style="font-size: 10px;">bower</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/docker/" style="font-size: 12.86px;">docker</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/git/" style="font-size: 11.43px;">git</a> <a href="/tags/http/" style="font-size: 12.86px;">http</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/laravel/" style="font-size: 10px;">laravel</a> <a href="/tags/linux/" style="font-size: 18.57px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 14.29px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 11.43px;">nodejs</a> <a href="/tags/patterns/" style="font-size: 11.43px;">patterns</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/rabbitmq/" style="font-size: 11.43px;">rabbitmq</a> <a href="/tags/redis/" style="font-size: 12.86px;">redis</a> <a href="/tags/rpc/" style="font-size: 10px;">rpc</a> <a href="/tags/shell/" style="font-size: 17.14px;">shell</a> <a href="/tags/singleton/" style="font-size: 10px;">singleton</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/urlencode/" style="font-size: 10px;">urlencode</a> <a href="/tags/varnish/" style="font-size: 10px;">varnish</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a>
    </div>
  </div>


  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/C/" title="C">C<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/arch/" title="arch">arch<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/books/" title="books">books<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/http/" title="http">http<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/java/" title="java">java<sup>3</sup></a></li>
		  
		
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>20</sup></a></li>
		  
		
		  
			<li><a href="/categories/mysql/" title="mysql">mysql<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/nginx/" title="nginx">nginx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/nodejs/" title="nodejs">nodejs<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/nosql/" title="nosql">nosql<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/other/" title="other">other<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/patterns/" title="patterns">patterns<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/php/" title="php">php<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/shell/" title="shell">shell<sup>1</sup></a></li>
		  
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="ericwang">ericwang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-47898532-4', 'auto');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
