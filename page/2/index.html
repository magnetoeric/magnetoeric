
 <!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta name="google-site-verification" content="0dfpYjYP37p5-odIMIJFaSXqgC0czlP_NcS4CoK8iew" />
  <meta charset="UTF-8">
  
    <title>艾瑞克</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ericwang">
    

    
    <meta name="description" content="精通java,php,c,c++,andriod,ios等单词的拼写,精通windows,linux,osx等系统的开关机,求一份扫地的工作">
<meta property="og:type" content="website">
<meta property="og:title" content="艾瑞克">
<meta property="og:url" content="http://magnetoeric.github.io/page/2/index.html">
<meta property="og:site_name" content="艾瑞克">
<meta property="og:description" content="精通java,php,c,c++,andriod,ios等单词的拼写,精通windows,linux,osx等系统的开关机,求一份扫地的工作">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="艾瑞克">
<meta name="twitter:description" content="精通java,php,c,c++,andriod,ios等单词的拼写,精通windows,linux,osx等系统的开关机,求一份扫地的工作">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="艾瑞克" title="艾瑞克"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="艾瑞克">艾瑞克</a></h1>
				<h2 class="blog-motto">艾瑞克的小站</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:magnetoeric.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/01/04/search/" title="常见搜索引擎的分布式解决方法" itemprop="url">常见搜索引擎的分布式解决方法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2017-01-04T11:59:00.000Z" itemprop="datePublished"> Published 2017-01-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文转自<a href="http://armsword.com/2017/01/16/distributed-solutions-for-search-engines/" target="_blank" rel="external">说说常见搜索引擎的分布式解决方法</a><br>随着索引数据的增大以及请求的增多，分布式搜索是最好的一种解决方案，主要解决两个问题，其一是能让单台机器load所有索引数据到内存中，其二是请求延时大，解决请求latency问题。我之前为团队写了篇专利，内容是关于分布式搜索解决方案的，所以粗略的看了下大部分开源的搜索引擎是怎么实现分布式的，后面的文章我会简单说下常见的搜索引擎的分布式解决方案。</p>
<p>首先我们先说下几个简单概念，分布式搜索都是M*N（横向切分数据，纵向切分流量）这个维度去解决问题的，虽然不同产品或场景概念不完全相同，读者可以简单认为一份完整的数据，被均分为M份，每一份被称为一个分配（Shard或者Partition），然后提供对每个Shard提供N份副本（Replica）。那么分布式的设计就围绕着以下问题：</p>
<ul>
<li>如何选择合适的分片(Shard)，副本(Replica)的数量</li>
<li>如何做路由，即怎么在所有Shard里找到一份完整的数据（找到对应的机器列表）</li>
<li>如何做负载均衡</li>
<li>如果提高服务的可扩展性</li>
<li>如何提高服务的服务能力（QPS），当索引和搜索并发量增大时，如何平滑解决</li>
<li>如何更新索引，全量和增量索引的更新解决方法</li>
<li>如果提高服务的稳定性，单台服务挂掉怎么不影响整体服务等等</li>
</ul>
<p>下面就说下常见的搜索引擎的分布式解决方案，因为开源的搜索产品基本上都没有在工作中用过，对代码细节并不是太了解，只是研究了下其原理，所以理解的会有些偏差，看官们如果发现错误直接指出即可。</p>
<h2 id="Sphinx-Coreseek"><a href="#Sphinx-Coreseek" class="headerlink" title="Sphinx/Coreseek"></a>Sphinx/Coreseek</h2><p>Sphinx的流程还是很简单的，可以看下其流程图：<br><img src="http://githubforericwang.qiniudn.com//hexo/eric/sphinx.png" alt="sphinx"><br>需要支持分布式的话，需要改下配置，大致是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">index dist</div><div class="line">&#123;</div><div class="line">  type = distributed</div><div class="line">  local = chunk1</div><div class="line">  agent = localhost:9312:chunk2  本地</div><div class="line">  agent = 192.168.100.2:9312:chunk3  远程</div><div class="line">  agent = 192.168.100.3:9312:chunk4  远程	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从图中也可以看出，需要在配置列表里配置好其他shard的地址。查询过程为：</p>
<ul>
<li>连接到远程代理</li>
<li>执行查询</li>
<li>对本地索引进行查询</li>
<li>接收来自远程代理的搜索结果</li>
<li>将所有结果合并，删除重复项</li>
<li>将合并后的结果返回给客户端<br>索引数据复制同步的方法也是常用的两种：</li>
</ul>
<p>主从同步<br>增量更新索引<br>方法也是设置crontab，添加2个选项，一个是重建主索引，一个是增量索引更新。</p>
<p>当然为了避免单点以及增加服务能力，肯定有多个Replica，解决方法应该也是配置或者haproxy相关的方法解决，从上面可以看出，Sphinx很难用，自动化能力太弱，所以很多大厂要么不再使用Sphinx要么基于其二次开发。</p>
<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p>Solr提供了两种方案来应对访问压力，其一是Replication，另一个是SolrCloud。我们此处只说Replication原理。<br>Replication采用了Master/Slave模式，也就是说由一个主索引和多个从索引构成，从索引从主索引复制索引，主索引负责更新索引，从索引负责同步索引和查询。本质上是读写分离的思想，MySQL/Redis等数据库也多是这种方式部署的。有两种部署方式：</p>
<ul>
<li>第一种<br><img src="http://githubforericwang.qiniudn.com/hexo/eric/solr.png" alt="solr-replica"></li>
<li>第二种<br><img src="http://githubforericwang.qiniudn.com/hexo/eric/solr_repeater.png" alt="solr-repeater"></li>
</ul>
<p>与第一种相比多了一层Repeater，Repeater既扮演了Master角色，又扮演了Slave功能，主要解决单个Master下Slave太多，Master压力太大的问题。</p>
<p>Master与Slave之间的通信是无状态的http连接，Slave端发送不同的Command从Master端获得数据。原理就是Master那边有个标志位和版本号，用于获取正确的数据版本，然后数据扔到Slave临时目录下，数据完整后，再覆盖原有数据。多个副本的方法应该与Sphinx相似，一般也是通过通过上游负载均衡模块如Nginx，HaProxy来分流。</p>
<h2 id="SolrCloud"><a href="#SolrCloud" class="headerlink" title="SolrCloud"></a>SolrCloud</h2><p>因为Solr Replication不好用，本质上还不算真正分布式的，所以Solr从4.0开始支持SolrCloud模式。特性不少，主要说两个吧：</p>
<p>配置文件统一管理，扔到Zookeeper上<br>自动做负载均衡和故障恢复，不再需要Nginx或HaProxy的支持<br>逻辑图<br><img src="http://githubforericwang.qiniudn.com/hexo/eric/solrcloud.png" alt="逻辑图"></p>
<ul>
<li>Collection：逻辑意义上一份完整的索引</li>
<li>Shard：上文已说，就是索引的1/N分片</li>
<li>Replica：Shard的一个拷贝<br>每个Shard，即相同的Replica下都会有一个leader，leader选举由Zookeeper完成。虽然有leader的概念，但是其实SolrCloud分布式是去中心化的，意思就是说，leader和非leader都能提供查询功能（也有修改和删除功能，搜索场景应用不多吧？），而更新索引，创建Collection/Shard/Replica（即扩容）只能由leader完成，避免产生并发修改问题，当非leader节点收到修改操作请求时，将信息存储在zookeeper中相应节点上，leader节点会一直对该节点进行watch，发现变化就实时做处理。</li>
</ul>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>任意节点收到创建索引请求后，转换成json格式存储到zk的/overseer/collection-queue-work的children节点上<br>leader线程一直监控collection-queue-work节点，检查到变化后，取出json数据，根据信息计算出需要创建的shard、replica，将创建具体replica的请求转向各对应节点<br>各节点创建完具体的replica后，将该节点的状态（创建成功与否等）更新到/overseer/queue的children节点上<br>leader线程监控/overseer/queue节点，将overseer/queue的children节点的状态更新至/clusterstate.json<br>各节点同步/clusterstate.json，整个集群状态得到更新，新索引创建成功</p>
<h3 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h3><p>根据路由规则计算出该doc所属shard，并找出该doc所属的shard对应的leader<br>如果当前Replica是对应Shard且是leader，首先更新本地索引，然后再将doc转向该Shard的其余Replica<br>扩容/缩容</p>
<p>停掉某台Solr，更新集群状态到/clusterstate.json<br>增加一台Solr，从leader出复制相同的数据，然后配置写到/clusterstate.json<br>查询</p>
<p>去中心的，leader和非leader一样功能，Replica接收搜索请求时，从Zookeeper中获取该Replica对应的Collection及所有的Shard和Replica<br>将请求发送到该Collection下对应的Shard，然后负载均衡到对应的Replica<br>SolrCloud也有其他功能，比如Optimization，就是一个运行在leader机器的进程，复杂压缩索引和归并Segment；近实时搜索等。总体看SolrCloud解决了Solr Replication遇到的一些问题，比Sphinx更好用，更自动化。</p>
<p>一号店</p>
<p>很多大一点的厂商如果不自研搜索引擎的话，并没有使用SolrCloud，而多基于Solr/Lucence。比如一号店的分布式搜索解决方案，如下所示：<br><a href="http://www.infoq.com/cn/articles/yhd-11-11-distributed-search-engine-architecture" target="_blank" rel="external">http://www.infoq.com/cn/articles/yhd-11-11-distributed-search-engine-architecture</a></p>
<p>Broker就相当于Proxy，扮演了路由功能，很多厂商做的与一号店有相似之处。因为没有leader选举，所以索引的更新就由其他模块来做了。</p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>ElasticSearch的倒排索引也是基于Lucence实现的。功能强大，不仅提供了实时搜索功能，还有分析功能，DB-Engines上面的搜索引擎排名，目前已经超越Solr排名第一位了。因为太强大了，功能也特别多，我研究还不够深，简单说下吧。<br>es会将集群名字相同的机器归为一个集群（业务），所以先说下启动过程。</p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p><img src="http://githubforericwang.qiniudn.com/hexo/eric/es_start.png" alt="es_start"><br>当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。</p>
<h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><p>与SolrCloud相似，也是去中心化的，但是没有使用Zookeeper，而是自己实现了分布式锁，选主的流程叫做 ZenDiscovery（详情见第三个参考链接）：</p>
<ul>
<li>节点启动后先ping（这里的ping是 Elasticsearch 的一个RPC命令。如果 discovery.zen.ping.unicast.hosts 有设置，则ping设置中的host，否则尝试ping localhost 的几个端口， Elasticsearch 支持同一个主机启动多个节点）</li>
<li>Ping的response会包含该节点的基本信息以及该节点认为的master节点</li>
<li>选举开始，先从各节点认为的master中选，规则很简单，按照id的字典序排序，取第一个</li>
<li>如果各节点都没有认为的master，则从所有节点中选择，规则同上。这里有个限制条件就是 discovery.zen.minimum_master_nodes，如果节点数达不到最小值的限制，则循环上述过程，直到节点数足够可以开始选举</li>
<li>最后选举结果是肯定能选举出一个master，如果只有一个local节点那就选出的是自己</li>
<li>如果当前节点是master，则开始等待节点数达到 minimum_master_nodes，然后提供服务</li>
<li>如果当前节点不是master，则尝试加入master</li>
<li>选举完leader后，主节点leader会去读取集群状态信息；因为主节点会监控其他节点，当其他节点出现故障时，会进行恢复工作。在这个阶段，主节点会去检查哪些分片可用，决定哪些分片作为主分片。</li>
</ul>
<p>选举完leader后，主节点leader会去读取集群状态信息；因为主节点会监控其他节点，当其他节点出现故障时，会进行恢复工作。在这个阶段，主节点会去检查哪些分片可用，决定哪些分片作为主分片。</p>
<p>分片</p>
<p>es在创建索引时，自己设置好分片个数，默认5个，整个过程类似于分裂的概念，如下图所示：</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/es_shard.svg" alt="es_shard"></p>
<p>至于读写、写操作等于SolrCloud相似，等我细研究后后续再说吧，也可以说下实时索引怎么做的，细节很多，下次再说吧。至于文中为什么不说Lucence，因为Lucence其实就是个index lib，只是解决倒排、正排索引怎么存放的，并不是一个完整的搜索引擎解决方案。而ES为什么能脱颖而出的主要原因是配套设施完善，工具，Web UI都是非常赞的，对于很多开源产品，它能后来居上的主要原因就是它真实的能解决用户遇到的问题或者比其他产品更好用。搜索引擎发展这么多年了，架构这块能做的基本上大家都差不太多，最后能脱颖而出的肯定是第三方工具做的更完善，更好用的了。</p>
<p>PS：<br>至于阿里搜索怎么做的，可以参考下这个文档，包括了阿里搜索里用到的很多基础模块了：<br><a href="https://share.weiyun.com/f66e79d9f6897d0aac683361531cf00d" target="_blank" rel="external">https://share.weiyun.com/f66e79d9f6897d0aac683361531cf00d</a></p>
<p>参考链接：<br><a href="http://blog.haohtml.com/archives/13724" target="_blank" rel="external">http://blog.haohtml.com/archives/13724</a><br><a href="http://www.voidcn.com/blog/u011026968/article/p-4922079.html" target="_blank" rel="external">http://www.voidcn.com/blog/u011026968/article/p-4922079.html</a><br><a href="http://jolestar.com/elasticsearch-architecture/" target="_blank" rel="external">http://jolestar.com/elasticsearch-architecture/</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/other/">other</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/solr/">solr</a><a href="/tags/elasticsearch/">elasticsearch</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/29/c_02/" title="linux下c语言编程" itemprop="url">linux下c语言编程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-11-29T12:14:00.000Z" itemprop="datePublished"> Published 2016-11-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="linux-下c语言编程"><a href="#linux-下c语言编程" class="headerlink" title="linux 下c语言编程"></a>linux 下c语言编程</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>GCC（GNU Compiler Collection，GNU编译器套装），是一套由 GNU 开发的编程语言编译器。它是一套以 GPL 及 LGPL 许可证所发行的自由软件，也是 GNU计划 的关键部分，亦是自由的 类Unix 及苹果计算机 Mac OS X 操作系统的标准编译器。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。在ubuntu等操作系统中编译安装大多数开源项目几乎都会用到gcc。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//hellp.c</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    printf(&quot;Hello World!\n&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单的编译: gcc hello.c -o hello<br>gcc 编译器就会为我们生成一个 hello 的可执行文件,执行./hello 就可以看到程序的输出结果了。命令行中 gcc 表示我们是用 gcc 来编译我们的源程序,-o 选项表示我们要求编译器 给我们输出的可执行文件名为 hello 而 hello.c 是我们的源程序文件。<br>实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。</p>
<p>gcc还有很多参数:<br>    -o 要求输出的可执行文件名。<br>    -c 要求编译器输出目标代码,而不必要输出可执行文件。<br>    -g 要求编译器在编译的时候提供我们以后对程序进行调试的信息。</p>
<h2 id="多个程序文件的编译"><a href="#多个程序文件的编译" class="headerlink" title="多个程序文件的编译"></a>多个程序文件的编译</h2><p>比如hello.c include了一些头，包含在hello1.h和hello2.h中,hello1.c和hello2.c也包含了这些头，需要编译多个文件<br>gcc -c hello.c<br>gcc -c hello1.c<br>gcc -c hello2.c<br>gcc hello.o hello1.o hello2.o -o hello</p>
<p>虽然这些命令可以使用shell脚本完成，但是大型的项目中会有很多源程序，不可能有一个改动就重新一个个编译。<br>因此就有了makefile，makefile带来的好处就是自动化编译，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><p>在 Makefile 中也#开始的行都是注释行.Makefile 中 最重要的是描述文件的依赖关系的说明.一般的格式是:<br>target: prerequisites<br>TAB command<br>第一行表示的是依赖关系,第二行是规则。</p>
<p>于是 hello的生成可以这么写 </p>
<p>hello:hello.o hello1.o hello2.o<br>    gcc -o hello hello.o hello1.o hello2.o<br>hello.o:hello.c hello1.h hello2.h<br>    gcc -c hello.c<br>hello1.o:hello1.c hello1.h<br>    gcc -c hello1.c<br>hello2.o:hello2.c hello2.h<br>    gcc -c hello2.c</p>
<p>Makefile 有三个非常有用的变量.分别是$@,$^,$&lt;代表的意义分别是: $@–目标文件,$^–所有的依赖文件,$&lt;–第一个依赖文件。<br>所以上面的可以写成<br>hello:hello.o hello1.o hello2.o<br>    gcc -o $@ $^<br>.c.o:<br>    gcc -c $&lt;</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>gdb工具，暂时没用到，先不看了</p>
<p>简单地了解下linux下C语言编程。有空得继续深入了</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/limux/">limux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/c/">c</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/29/guid/" title="guid" itemprop="url">guid</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-11-29T11:55:00.000Z" itemprop="datePublished"> Published 2016-11-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="分布式id生成器"><a href="#分布式id生成器" class="headerlink" title="分布式id生成器"></a>分布式id生成器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>有些人也喜欢叫发号器，一般是作为服务运行，主要目的是就是为一个系统的数据对象分配一个唯一id。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>唯一性</li>
<li>时间段内粗略有序</li>
<li>可制造</li>
<li>可反解</li>
</ul>
<p>一般来说，id生成器的要求主要是一下几点:</p>
<ul>
<li>快速响应，可以毫秒级并发</li>
<li>高可用性</li>
<li>体积小(存储)</li>
</ul>
<p>这里不讨论uuid<a href="http://kccoder.com/mysql/uuid-vs-int-insert-performance/" target="_blank" rel="external">uuid-vs-int-insert-performance</a></p>
<h2 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h2><h3 id="自增有序"><a href="#自增有序" class="headerlink" title="自增有序"></a>自增有序</h3><p>这种方式可以利用mysql的自增id。但是使用mysql有一些瓶颈:</p>
<ul>
<li>单点问题(高可用性)</li>
<li>并发</li>
</ul>
<p>flickr巧妙的利用replace实现分布式发号器<br>自增id使用big int  为了提高并发，使用多台mysql机器，每台机器设置不同的起始值和步长，sql使用replace唯一id的方式使得mysql每次增长一个步长(insert on duplacate key也可以，update不可以,是因为update的返回值是成功还是失败)<br>表结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `Tickets64` (</div><div class="line">  `id` bigint(20) unsigned NOT NULL auto_increment,</div><div class="line">  `stub` char(1) NOT NULL default &apos;&apos;,</div><div class="line">  PRIMARY KEY  (`id`),</div><div class="line">  UNIQUE KEY `stub` (`stub`)</div><div class="line">) ENGINE=MyISAM</div></pre></td></tr></table></figure>
<p>sql语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">REPLACE INTO Tickets64 (stub) VALUES (&apos;a&apos;);</div><div class="line">SELECT LAST_INSERT_ID();</div></pre></td></tr></table></figure>
<p>设置步长和起始值(步长也可以直接在session中指定)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TicketServer1:</div><div class="line">auto-increment-increment = 2</div><div class="line">auto-increment-offset = 1</div><div class="line"></div><div class="line">TicketServer2:</div><div class="line">auto-increment-increment = 2</div><div class="line">auto-increment-offset = 2</div></pre></td></tr></table></figure>
<p>php 实现，java无法使用jpa，可以用jdbcTemplate实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">include_once &apos;pdoFactory.php&apos;;</div><div class="line">// insert</div><div class="line">//$sql = &quot;INSERT INTO Tickets64 (stub) VALUES (&apos;a&apos;) ON DUPLiCATE KEY UPDATE id=id+1&quot;;</div><div class="line">// replace</div><div class="line">$sql = &quot;REPLACE INTO Tickets64 (stub) VALUES (&apos;a&apos;)&quot;;</div><div class="line"></div><div class="line">$pdo = pdoFactory::getInstance()-&gt;getPdo(&apos;default&apos;);</div><div class="line">$p = $pdo-&gt;exec($sql);</div><div class="line">echo &quot;&lt;pre&gt;&quot;;print_r($pdo-&gt;lastInsertId());exit;</div></pre></td></tr></table></figure>
<p>优缺点</p>
<p>优点是简单，实现快速。</p>
<p>缺点是mysql中需要设置起始值，需要多台mysql服务，可扩展性差。并发取决于mysql节点数量</p>
<p>架构图</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/autoincreament.png" alt=""></p>
<p>腾讯的seqsvr <a href="http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650992918&amp;idx=1&amp;sn=be5121c3c57257291a30715ef7130a90&amp;scene=23&amp;srcid=0628Xb1bDyZ2EdvPffymi6za#rd" target="_blank" rel="external">万亿级调用系统：微信序列号生成器架构设计及演变</a><br>简单来讲，seqsvr是一个巨大的long数组,每个元素代表一个用户，比如小明的uid是12,那么seq[12]就是他产生的guid，每个用户(元素)之间产生的uid互不影响,每个uid产生的guid严格递增(为了保证这一点，付出的代价很高，不能使用负载均衡，同一时间只有一个服务器产生该用户的guid)，发号分为两层，下层是持久化层，主要存储当前uid产生的最大的guid，上层为缓存层，缓存一个步长，用来发号。也做了很多优化，比如设置最大临时guid,相邻的uid共享该max_guid，这样在服务器重启时可以大大减少向存储层发起的请求，减少内存使用。容灾问题上做了很多处理，前面说到这种方式存在单点问题，seqsrv做了很多，分set做隔离，路由和配置服务做失败请求，仲裁服务做服务切换</p>
<h3 id="时间有序"><a href="#时间有序" class="headerlink" title="时间有序"></a>时间有序</h3><p>主流的方式都是类似twitter的snowflake，一个long是64字节，可以根据自身业务特点选择秒级别还是毫秒级别，一般系统寿命在30年左右，所以毫秒级别需要41位表示时间，秒级别需要30位，剩下的需要几位去表示机器号，也可以预留2位表示版本，方便切换</p>
<p>摘自<a href="http://ericliang.info/what-kind-of-id-generator-we-need-in-business-systems/" target="_blank" rel="external">一乐:业务系统需要什么样的ID生成器</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">SnowFlake</div><div class="line"></div><div class="line">41bit留给毫秒时间，10bit给MachineID，也就是机器要预先配置，剩下12位留给Sequence。</div><div class="line"></div><div class="line">Weibo</div><div class="line"></div><div class="line">微博使用了秒级的时间，用了30bit，Sequence 用了15位，理论上可以搞定3.2w/s的速度。用4bit来区分IDC，也就是可以支持16个 IDC，对于核心机房来说够了。剩下的有2bit 用来区分业务，由于当前发号服务是机房中心式的，1bit 来区分热备。是的，也没有用满64bit。</div><div class="line"></div><div class="line">Ticktick</div><div class="line"></div><div class="line">也就是当前在环信系统里要用到的。使用了30bit 的秒级时间，20bit 给Sequence。这里是有个考虑，第一版实现还是希望到毫秒级，所以20bit 的前10bit给了毫秒来用，剩下10bit给 Sequence。等到峰值提高的时候可以暂时回到秒级。</div><div class="line"></div><div class="line">前面说到的三十年问题，因此我在高位留了2bit 做 Version，或者到时候改造使用更长字节数，用第一位来标识不同 ID，或者可以把这2bit 挪给时间用，可以给系统改造留出一定的时间。</div><div class="line"></div><div class="line">剩下的10bit 留给 MachineID，也就是说当前 ID 生成可以直接内嵌在业务服务中，最多支持千级别的服务器数量。最后有2bit 做Tag 用，可能区分群消息和单聊消息。同时你也看出，这个 ID 最多支持一天10亿消息，也是怕系统增速太快，这2bit 可以挪给 Sequence，可以支持40亿级别消息量，或者结合前面的版本支持到百亿级别。</div><div class="line"></div><div class="line">修正：评论里指出上面一个计算错误，不挪借的话应该是支持一天约千亿级别。对比当前 Whatsapp 的600亿和腾讯 QQ 的200亿，已经足够了。</div></pre></td></tr></table></figure>
<p>snowflake</p>
<p>优点:可用性强</p>
<p>缺点:依赖zookeeper，要么人肉做配置，总之需要在服务中配置机器号识别。</p>
<p>Instagram<br><a href="http://instagram-engineering.tumblr.com/post/10853187575/sharding-ids-at-instagram" target="_blank" rel="external">sharding-ids-at-instagram</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CREATE OR REPLACE FUNCTION insta5.next_id(OUT result bigint) AS $$</div><div class="line">DECLARE</div><div class="line">    our_epoch bigint := 1314220021721;</div><div class="line">    seq_id bigint;</div><div class="line">    now_millis bigint;</div><div class="line">    shard_id int := 5;</div><div class="line">BEGIN</div><div class="line">    SELECT nextval(&apos;insta5.table_id_seq&apos;) %% 1024 INTO seq_id;</div><div class="line"></div><div class="line">    SELECT FLOOR(EXTRACT(EPOCH FROM clock_timestamp()) * 1000) INTO now_millis;</div><div class="line">    result := (now_millis - our_epoch) &lt;&lt; 23;</div><div class="line">    result := result | (shard_id &lt;&lt; 10);</div><div class="line">    result := result | (seq_id);</div><div class="line">END;</div><div class="line">$$ LANGUAGE PLPGSQL;</div></pre></td></tr></table></figure>
<p>也是类似snowflake,直接在postgrsql中实现的。简单看了一下，类似触发器，id自增换成函数生成<br>达达的也类似<a href="http://www.infoq.com/cn/articles/imdada-high-performance-server-optimization/" target="_blank" rel="external">达达-高性能服务端优化之路</a></p>
<p>优： 开发成本低<br>劣： 基于postgreSQL的存储过程，较为偏门</p>
<p>基于redis的id生成器</p>
<p>基于redis的id生成器(<a href="http://blog.csdn.net/hengyunabc/article/details/44244951" target="_blank" rel="external">http://blog.csdn.net/hengyunabc/article/details/44244951</a>)</p>
<p>优点:利用redis lua脚本实现，少量机器即可满足需求</p>
<p>缺点: 需要配置redis起始值及步长</p>
<p>一些变种</p>
<p>Hibernate <a href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/id/uuid/CustomVersionOneStrategy.java" target="_blank" rel="external">github</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- 时间戳(6bytes, 48bit)：毫秒级别的，从1970年算起，能撑8925年....</div><div class="line">- 顺序号(2bytes, 16bit, 最大值65535): 没有时间戳过了一秒要归零的事，各搞各的，short溢出到了负数就归0。</div><div class="line">- 机器标识(4bytes 32bit): 拿localHost的IP地址，IPV4呢正好4个byte，但如果是IPV6要16个bytes，就只拿前4个byte。</div><div class="line">- 进程标识(4bytes 32bit)： 用当前时间戳右移8位再取整数应付，不信两条线程会同时启动。</div><div class="line"></div><div class="line">值得留意就是，机器进程和进程标识组成的64bit Long几乎不变，只变动另一个Long就够了。</div></pre></td></tr></table></figure>
<p>mongodb <a href="https://docs.mongodb.com/manual/reference/bson-types/#objectid" target="_blank" rel="external">Mongdodb objectId</a> 非long型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- 时间戳(4 bytes 32bit): 是秒级别的，从1970年算起，能撑136年。</div><div class="line"></div><div class="line">- 自增序列(3bytes 24bit, 最大值一千六百万)： 是一个从随机数开始（机智）的Int不断加一，也没有时间戳过了一秒要归零的事，各搞各的。因为只有3bytes，所以一个4bytes的Int还要截一下后3bytes。</div><div class="line"></div><div class="line">- 机器标识(3bytes 24bit): 将所有网卡的Mac地址拼在一起做个HashCode，同样一个int还要截一下后3bytes。搞不到网卡就用随机数混过去。</div><div class="line"></div><div class="line">- 进程标识(2bytes 16bits)：从JMX里搞回来到进程号，搞不到就用进程名的hash或者随机数混过去。</div><div class="line"></div><div class="line">可见，MongoDB的每一个字段设计都比Hibernate的更合理一点，比如时间戳是秒级别的。总长度也降到了12 bytes 96bit，但如果果用64bit长的Long来保存有点不上不下的，只能表达成byte数组或16进制字符串。</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://calvin1978.blogcn.com/articles/uuid.html" target="_blank" rel="external">江南白衣:分布式Unique ID的生成方法一览</a></p>
<p><a href="http://ericliang.info/what-kind-of-id-generator-we-need-in-business-systems/" target="_blank" rel="external">一乐:业务系统需要什么样的ID生成器</a></p>
<p><a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="external">flickr Ticket Servers: Distributed Unique Primary Keys on the Cheap</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/arch/">arch</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/arch/">arch</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/17/split/" title="利用shell脚本对大文件进行分割" itemprop="url">利用shell脚本对大文件进行分割</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-11-17T02:52:00.000Z" itemprop="datePublished"> Published 2016-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="利用shell脚本对大文件进行分割"><a href="#利用shell脚本对大文件进行分割" class="headerlink" title="利用shell脚本对大文件进行分割"></a>利用shell脚本对大文件进行分割</h1><p>日常应用产生的日志是需要做文件分割的,无论是按文件大小还是按时间</p>
<p>##　利用shell脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash  </div><div class="line">   </div><div class="line">  lines=`wc   -l   xxx.log|   awk   &apos;&#123;print   $1&#125;&apos;`  </div><div class="line">  i=1  </div><div class="line">  file_suffix=1  </div><div class="line">  while   [   $i   -lt   $lines   ]  </div><div class="line">  do  </div><div class="line">                  next=`expr   $i   +   999`  </div><div class="line">                  sed   -n   &quot;$&#123;i&#125;,   $&#123;next&#125;p&quot;   xxx.log &gt;   file_$file_suffix.log    </div><div class="line">                  n1=`expr   $n2   +   1`  </div><div class="line">                  file_suffix=`expr   $file_suffix   +   1`  </div><div class="line">  done</div></pre></td></tr></table></figure></p>
<p>实现了每1000行来分割文件</p>
<h2 id="使用工具split"><a href="#使用工具split" class="headerlink" title="使用工具split"></a>使用工具split</h2><p>split 参数：<br>-b  : 后面可接欲分割成的档案大小，可加单位，例如 b, k, m 等；<br>-l  : 以行数来进行分割；<br>-d  : 默认是以字符为后缀的,使用-d 或者–numeric-suffixes  可以改变后缀<br>查看参数更多可以　<code>man split</code></p>
<p>1.按每个文件1000行来分割除<br>split -l 1000 access.log split<br>会切割成splitaa splitab splitac…</p>
<p>2.按照每个文件100K来分割<br>split -l 1000 access.log split<br>会切割成httpaa，httpab，httpac ……..</p>
<p>3.流切割<br>对于流split一样可以做到<br>简单点举例<br>cat access.log | split -l 1000 split<br>这样有些守护进程就可以这样写<br>php xxx.php | split -l 10000 xxx.log.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/11/17/union/" title="并查集" itemprop="url">并查集</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-11-17T02:47:00.000Z" itemprop="datePublished"> Published 2016-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="数据结构之并查集"><a href="#数据结构之并查集" class="headerlink" title="数据结构之并查集"></a>数据结构之并查集</h1><p>文章转自<a href="http://dongxicheng.org/structure/union-find-set/" target="_blank" rel="external">数据结构之并查集</a>;</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>并查集（Disjoint set或者Union-find set）是一种树型的数据结构，常用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>并查集是一种非常简单的数据结构，它主要涉及两个基本操作，分别为：</p>
<ul>
<li><p>合并两个不相交集合</p>
</li>
<li><p>判断两个元素是否属于同一个集合</p>
</li>
</ul>
<p>1.合并两个不相交集合（Union(x,y)）</p>
<p>合并操作很简单：先设置一个数组Father[x]，表示x的“父亲”的编号。那么，合并两个不相交集合的方法就是，找到其中一个集合最父亲的父亲（也就是最久远的祖先），将另外一个集合的最久远的祖先的父亲指向它。<br><img src="http://githubforericwang.qiniudn.com/hexo/eric/union.jpg" alt="union"></p>
<p>上图为两个不相交集合，b图为合并后Father(b):=Father(g)</p>
<p>2.判断两个元素是否属于同一集合（Find_Set(x)）</p>
<p>本操作可转换为寻找两个元素的最久远祖先是否相同。可以采用递归实现。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>1.Find_Set(x)时，路径压缩</p>
<p>寻找祖先时，我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度。为了避免这种情况，我们需对路径进行压缩，即当我们经过”递推”找到祖先节点后，”回溯”的时候顺便将它的子孙节点都直接指向祖先，这样以后再次Find_Set(x)时复杂度就变成O(1)了，如下图所示。可见，路径压缩方便了以后的查找。</p>
<p><img src="http://githubforericwang.qiniudn.com/hexo/eric/optimization.jpg" alt=""></p>
<p>2.Union(x,y)时，按秩合并</p>
<p>即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">int father[MAX];   /* father[x]表示x的父节点*/</div><div class="line"> </div><div class="line">int rank[MAX];     /*rank[x]表示x的秩*/</div><div class="line"> </div><div class="line">&amp;nbsp;</div><div class="line"> </div><div class="line">void Make_Set(int x)</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">father[x] = x; //根据实际情况指定的父节点可变化</div><div class="line"> </div><div class="line">rank[x] = 0;   //根据实际情况初始化秩也有所变化</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">/* 查找x元素所在的集合,回溯时压缩路径*/</div><div class="line"> </div><div class="line">int Find_Set(int x)</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">if (x != father[x])</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">father[x] = Find_Set(father[x]); //这个回溯时的压缩路径是精华</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">return father[x];</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">/*</div><div class="line"> </div><div class="line">按秩合并x,y所在的集合</div><div class="line"> </div><div class="line">下面的那个if else结构不是绝对的，具体根据情况变化</div><div class="line"> </div><div class="line">但是，宗旨是不变的即，按秩合并，实时更新秩。</div><div class="line"> </div><div class="line">*/</div><div class="line"> </div><div class="line">void Union(int x, int y)</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">x = Find_Set(x);</div><div class="line"> </div><div class="line">y = Find_Set(y);</div><div class="line"> </div><div class="line">if (x == y) return;</div><div class="line"> </div><div class="line">if (rank[x] &gt; rank[y])</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">father[y] = x;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">else</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">if (rank[x] == rank[y])</div><div class="line"> </div><div class="line">&#123;</div><div class="line"> </div><div class="line">rank[y]++;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">father[x] = y;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>空间复杂度为O(N)，建立一个集合的时间复杂度为O(1)，N次合并M查找的时间复杂度为O(M Alpha(N))，这里Alpha是Ackerman函数的某个反函数，在很大的范围内（人类目前观测到的宇宙范围估算有10的80次方个原子，这小于前面所说的范围）这个函数的值可以看成是不大于4的，所以并查集的操作可以看作是线性的。具体复杂度分析过程见参考资料（3）。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>并查集常作为另一种复杂的数据结构或者算法的存储结构。常见的应用有：求无向图的连通分量个数，最近公共祖先（LCA），带限制的作业排序，实现Kruskar算法求最小生成树等。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p>并查集：<a href="http://www.nocow.cn/index.php/%E5%B9%B6%E6%9F%A5%E9%9B%86" target="_blank" rel="external">http://www.nocow.cn/index.php/%E5%B9%B6%E6%9F%A5%E9%9B%86</a></p>
</li>
<li><p>博文《并查集详解》：<a href="http://www.cnblogs.com/cherish_yimi/" target="_blank" rel="external">http://www.cnblogs.com/cherish_yimi/</a></p>
</li>
<li><p>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 21: Data structures for Disjoint Sets, pp. 498–524.</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/other/">other</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数据结构/">数据结构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/14/shell-4/" title="SHELL编程之内建命令" itemprop="url">SHELL编程之内建命令</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-06-14T03:59:00.000Z" itemprop="datePublished"> Published 2016-06-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>文章转自<a href="http://liwei.life/2016/06/13/shell编程之内建命令/" target="_blank" rel="external">SHELL编程之内建命令</a></p>
<p><strong> 微博ID：orroz </strong></p>
<p><strong> 微信公众号：Linux系统技术 </strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是shell编程系列的第五篇，集中介绍了bash相关内建命令的使用。通过学习本文内容，可以帮你解决以下问题：</p>
<ol>
<li>什么是内建命令？为什么要有内建命令？</li>
<li>为啥echo 111 222 333 444 555| read -a test之后echo ${test[*]}不好使？</li>
<li>./script和. script有啥区别？</li>
<li>如何让让kill杀不掉你的bash脚本？</li>
<li>如何更优雅的处理bash的命令行参数</li>
</ol>
<h3 id="为什么要有内建命令"><a href="#为什么要有内建命令" class="headerlink" title="为什么要有内建命令"></a>为什么要有内建命令</h3><p>内建命令是指bash内部实现的命令。bash在执行这些命令的时候不同于一般外部命令的fork、exec、wait的处理过程，这内建功能本身不需要打开一个子进程执行，而是bash本身就可以进行处理。分析外部命令的执行过程我们可以理解内建命令的重要性，外建命令都会打开一个子进程执行，所以有些功能没办法通过外建命令实现。比如当我们想改变当前bash进程的某些环境的时候，如：切换当前进程工作目录，如果打开一个子进程，切换之后将会改变子进程的工作目录，与当前bash没关系。所以内建命令基本都是从必须放在bash内部实现的命令。bash所有的内建命令只有50多个，绝大多数的命令我们在之前的介绍中都已经使用过了。下面我们就把它们按照使用的场景分类之后，分别介绍一下在bash编程中可能会经常用到的内建命令。</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>对于任何编程语言来说，程序跟文件的输入输出都是非常重要的内容，bash编程当然也不例外。所有的shell编程与其他语言在IO处理这一块的最大区别就是，shell可以直接使用命令进行处理，而其他语言基本上都要依赖IO处理的库和函数进行处理。所以对于shell编程来说，IO处理的相关代码写起来要简单的多。本节我们只讨论bash内建的IO处理命令，而外建的诸如grep、sed、awk这样的高级处理命令不在本文的讨论范围内。</p>
<p>source：</p>
<p>.：</p>
<p>以上两个命令：source和.实际上是同一个内建命令，它们的功能完全一样，只是两种不同写法。我们都应该见过这样一种写法，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for i in /etc/profile.d/*.sh; do</div><div class="line">    if [ -r &quot;$i&quot; ]; then</div><div class="line">        if [ &quot;$PS1&quot; ]; then</div><div class="line">            . &quot;$i&quot;</div><div class="line">        else</div><div class="line">            . &quot;$i&quot; &gt;/dev/null 2&gt;&amp;1</div><div class="line">        fi</div><div class="line">    fi</div><div class="line">done</div></pre></td></tr></table></figure>
<p>这里的”. $i”实际上就是source $i。这个命令的含义是：读取文件的内容，并在当前bash环境下将其内容当命令执行。注意，这与输入一个可执行脚本的路径的执行方式是不同的。路径执行的方式会打开一个子进程的bash环境去执行脚本中的内容，而source方式将会直接在当前bash环境中执行其内容。所以这种方式主要用于想引用一个脚本中的内容用来改变当前bash环境。如：加载环境变量配置脚本或从另一个脚本中引用其定义的函数时。我们可以通过如下例子来理解一下这个内建命令的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat source.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">aaa=1000</div><div class="line"></div><div class="line">echo $aaa</div><div class="line">echo $$</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./source.sh </div><div class="line">1000</div><div class="line">27051</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ . source.sh </div><div class="line">1000</div><div class="line">17790</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $$</div><div class="line">17790</div></pre></td></tr></table></figure>
<p>我们可以通过以上例子中的$aaa变量看到当前bash环境的变化，可以通过$$变量，看到不同执行过程的进程环境变化。</p>
<p>read：</p>
<p>这个命令可以让bash从标准输入读取输字符串到一个变量中。用法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat input.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">read -p &quot;Login: &quot; username</div><div class="line"></div><div class="line">read -p &quot;Passwd: &quot; password</div><div class="line"></div><div class="line">echo $username</div><div class="line"></div><div class="line">echo $password</div></pre></td></tr></table></figure>
<p>程序执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./input.sh </div><div class="line">Login: zorro</div><div class="line">Passwd: zorro</div><div class="line">zorro</div><div class="line">zorro</div></pre></td></tr></table></figure>
<p>我们可以利用read命令实现一些简单的交互程序。read自带提示输出功能，-p参数可以让read在读取输入之前先打印一个字符串。read命令除了可以读取输入并赋值一个变量以外，还可以赋值一个数组，比如我们想把一个命令的输出读到一个数组中，使用方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat read.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"></div><div class="line">read -a test</div><div class="line"></div><div class="line">echo $&#123;test[*]&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./read.sh </div><div class="line">111 222 333 444 555</div><div class="line">111 222 333 444 555</div></pre></td></tr></table></figure>
<p>输入为：111 222 333 444 555，就会打印出整个数组列表。</p>
<p>mapfile：</p>
<p>readarray：</p>
<p>这两个命令又是同一个命令的两种写法。它们的功能是，将一个文本文件直接变成一个数组，每行作为数组的一个元素。这对某些程序的处理是很方便的。尤其是当你要对某些文件进行全文的分析或者处理的时候，比一行一行读进来处理方便的多。用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat mapfile.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">exec 3&lt; /etc/passwd</div><div class="line"></div><div class="line">mapfile -u 3 passwd </div><div class="line"></div><div class="line">exec 3&lt;&amp;-</div><div class="line"></div><div class="line">echo $&#123;#passwd&#125;</div><div class="line"></div><div class="line">for ((i=0;i&lt;$&#123;#passwd&#125;;i++))</div><div class="line">do</div><div class="line">    echo $&#123;passwd[$i]&#125;</div><div class="line">done</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./mapfile.sh </div><div class="line">32</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/usr/bin/nologin</div><div class="line">daemon:x:2:2:daemon:/:/usr/bin/nologin</div><div class="line">...</div></pre></td></tr></table></figure>
<p>本例子中使用了-u参数，表示让mapfile或readarray命令从一个文件描述符读取，如果不指定文件描述符，命令将默认从标准输入读取。所以很多人可能习惯用管道的方式读取，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat /etc/passwd|mapfile passwd</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;passwd[*]&#125;</div></pre></td></tr></table></figure>
<p>但是最后却发现passwd变量根本不存在。这个原因是：如果内建命令放到管道环境中执行，那么bash会给它创建一个subshell进行处理。于是创建的数组实际上与父进程没有关系。这点是使用内建命令需要注意的一点。同样，read命令也可能会出现类似的使用错误。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo 111 222 333 444 555| read -a test</div></pre></td></tr></table></figure>
<p>执行完之后，我们在bash脚本环境中仍然无法读取到test变量的值，也是同样的原因。</p>
<p>mapfile的其他参数，大家可以自行参考help mapfile或help readarray取得帮助。</p>
<p>echo：</p>
<p>printf：</p>
<p>这两个都是用来做输出的命令，其中echo是我们经常使用的，就不啰嗦了，具体参数可以help echo。printf命令是一个用来进行格式化输出的命令，跟C语言或者其他语言的printf格式化输出的方法都类似，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ printf &quot;%d\t%s %f\n&quot; 123 zorro 1.23</div><div class="line">123 zorro 1.230000</div></pre></td></tr></table></figure>
<p>使用很简单，具体也请参见：help printf。</p>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制指的是jobs功能。一般情况下bash执行命令的方式是打开一个子进程并wait等待其退出，所以bash在等待一个命令执行的过程中不能处理其他命令。而jobs功能给我们提供了一种办法，可以让bash不用显示的等待子进程执行完毕后再处理别的命令，在命令行中使用这个功能的方法是在命令后面加&amp;符号，表明进程放进作业控制中处理，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ sleep 3000 &amp;</div><div class="line">[1] 30783</div><div class="line">[zorro@zorrozou-pc0 bash]$ sleep 3000 &amp;</div><div class="line">[2] 30787</div><div class="line">[zorro@zorrozou-pc0 bash]$ sleep 3000 &amp;</div><div class="line">[3] 30791</div><div class="line">[zorro@zorrozou-pc0 bash]$ sleep 3000 &amp;</div><div class="line">[4] 30795</div><div class="line">[zorro@zorrozou-pc0 bash]$ sleep 3000 &amp;</div><div class="line">[5] 30799</div></pre></td></tr></table></figure>
<p>我们放了5个sleep进程进入jobs作业控制。大家可以当作这是bash提供给我们的一种“并发处理”方式。此时我们可以使用jobs命令查看作业系统中有哪些进程在执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ jobs</div><div class="line">[1]   Running                 sleep 3000 &amp;</div><div class="line">[2]   Running                 sleep 3000 &amp;</div><div class="line">[3]   Running                 sleep 3000 &amp;</div><div class="line">[4]-  Running                 sleep 3000 &amp;</div><div class="line">[5]+  Running                 sleep 3000 &amp;</div></pre></td></tr></table></figure>
<p>除了数字外，这里还有+和-号标示。+标示当前作业任务，-表示备用的当前作业任务。所谓的当前作业，就是最后一个被放到作业控制中的进程，而备用的则是当前进程如果退出，那么备用的就会变成当前的。这些jobs进程可以使用编号和PID的方式控制，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ kill %1</div><div class="line">[1]   Terminated              sleep 3000</div><div class="line">[zorro@zorrozou-pc0 bash]$ jobs</div><div class="line">[2]   Running                 sleep 3000 &amp;</div><div class="line">[3]   Running                 sleep 3000 &amp;</div><div class="line">[4]-  Running                 sleep 3000 &amp;</div><div class="line">[5]+  Running                 sleep 3000 &amp;</div></pre></td></tr></table></figure>
<p>表示杀掉1号作业任务，还可以使用kill %+或者kill %-以及kill %%（等同于%+）。除了可以kill这些进程以外，bash还提供了其他控制命令：</p>
<p>fg：<br>bg：</p>
<p>将指定的作业进程回到前台让当前bash去wait。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ fg %5</div><div class="line">sleep 3000</div></pre></td></tr></table></figure>
<p>于是当前bash又去“wait”5号作业任务了。当然fg后面也可以使用%%、％+、%-等符号，如果fg不加参数效果跟fg %+也是一样的。让一个当前bash正在wait的进程回到作业控制，可以使用ctrl+z快捷键，这样会让这个进程处于stop状态：</p>
<p>[zorro@zorrozou-pc0 bash]$ fg %5<br>sleep 3000<br>^Z<br>[5]+  Stopped                 sleep 3000</p>
<p>[zorro@zorrozou-pc0 bash]$ jobs<br>[2]   Running                 sleep 3000 &amp;<br>[3]   Running                 sleep 3000 &amp;<br>[4]-  Running                 sleep 3000 &amp;<br>[5]+  Stopped                 sleep 3000</p>
<p>这个进程目前是stopped的，想让它再运行起来可以使用bg命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ bg %+</div><div class="line">[5]+ sleep 3000 &amp;</div><div class="line">[zorro@zorrozou-pc0 bash]$ jobs</div><div class="line">[2]   Running                 sleep 3000 &amp;</div><div class="line">[3]   Running                 sleep 3000 &amp;</div><div class="line">[4]-  Running                 sleep 3000 &amp;</div><div class="line">[5]+  Running                 sleep 3000 &amp;</div></pre></td></tr></table></figure>
<p>disown：</p>
<p>disown命令可以让一个jobs作业控制进程脱离作业控制，变成一个“野”进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ disown </div><div class="line">[zorro@zorrozou-pc0 bash]$ jobs</div><div class="line">[2]   Running                 sleep 3000 &amp;</div><div class="line">[3]-  Running                 sleep 3000 &amp;</div><div class="line">[4]+  Running                 sleep 3000 &amp;</div></pre></td></tr></table></figure>
<p>直接回车的效果跟diswon ％+是一样的，也是处理当前作业进程。这里要注意的是，disown之后的进程仍然是还在运行的，只是bash不会wait它，jobs中也不在了。</p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><p>进程在系统中免不了要处理信号，即使是bash。我们至少需要使用命令给别进程发送信号，于是就有了kill命令。kill这个命令应该不用多说了，但是需要大家更多理解的是信号的概念。大家可以使用kill -l命令查看信号列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ kill -l</div><div class="line"> 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP</div><div class="line"> 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1</div><div class="line">11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM</div><div class="line">16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP</div><div class="line">21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ</div><div class="line">26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR</div><div class="line">31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</div><div class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</div><div class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</div><div class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</div><div class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</div><div class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</div><div class="line">63) SIGRTMAX-1  64) SIGRTMAX</div></pre></td></tr></table></figure>
<p>每个信号的意思以及进程接收到相关信号的默认行为了这个内容大家可以参见《UNIX环境高级编程》。我们在此先只需知道，常用的信号有2号（crtl c就是发送2号信号），15号（kill默认发送），9号（著名的kill -9）这几个就可以了。其他我们还需要知道，这些信号绝大多数是可以被进程设置其相应行为的，除了9号和19号信号。这也是为什么我们一般用kill直接无法杀掉的进程都会再用kill -9试试的原因。</p>
<p>那么既然进程可以设置信号的行为，bash中如何处理呢？使用trap命令。方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat trap.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">trap &apos;echo hello&apos; 2 15</div><div class="line">trap &apos;exit 17&apos; 3</div><div class="line"></div><div class="line">while :</div><div class="line">do</div><div class="line">    sleep 1</div><div class="line">done</div></pre></td></tr></table></figure>
<p>trap命令的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">trap [-lp] [[arg] signal_spec ...]</div></pre></td></tr></table></figure>
<p>在我们的例子中，第一个trap命令的意思是，定义针对2号和15号信号的行为，当进程接收到这两个信号的时候，将执行echo hello。第二个trap的意思是，如果进程接收到3号信号将执行exit 17，以17为返回值退出进程。然后我们来看一下进程执行的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./trap.sh </div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">hello</div><div class="line">hello</div></pre></td></tr></table></figure>
<p>此时按ctrl+c和kill这个bash进程都会让进程打印hello。3号信号可以用ctrl+\发送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./trap.sh </div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">^Chello</div><div class="line">hello</div><div class="line">hello</div><div class="line">^\Quit (core dumped)</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $?</div><div class="line">17</div></pre></td></tr></table></figure>
<p>此时进程退出，返回值是17，而不是128+3=131。这就是trap命令的用法。</p>
<p>suspend：</p>
<p>bash还提供了一种让bash执行暂停并等待信号的功能，就是suspend命令。它等待的是18号SIGCONT信号，这个信号本身的含义就是让一个处在T（stop）状态的进程恢复运行。使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat suspend.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">pid=$$</div><div class="line"></div><div class="line">echo &quot;echo $pid&quot;</div><div class="line">#打开jobs control功能，在没有这个功能suspend无法使用，脚本中默认此功能关闭。</div><div class="line">#我们并不推荐在脚本中开启此功能。</div><div class="line">set -m</div><div class="line"></div><div class="line">echo &quot;Begin!&quot;</div><div class="line"></div><div class="line">echo $-</div><div class="line"></div><div class="line">echo &quot;Enter suspend stat:&quot;</div><div class="line"></div><div class="line">#让一个进程十秒后给本进程发送一个SIGCONT信号</div><div class="line">( sleep 10 ; kill -18 $pid ) &amp;</div><div class="line">#本进程进入等待</div><div class="line">suspend </div><div class="line"></div><div class="line">echo &quot;Get SIGCONT and continue running.&quot;</div><div class="line"></div><div class="line">echo &quot;End!&quot;</div></pre></td></tr></table></figure>
<p>执行效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./suspend.sh </div><div class="line">echo 31833</div><div class="line">Begin!</div><div class="line">hmB</div><div class="line">Enter suspend stat:</div><div class="line"></div><div class="line">[1]+  Stopped                 ./suspend.sh</div></pre></td></tr></table></figure>
<p>十秒之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ </div><div class="line">[zorro@zorrozou-pc0 bash]$ Get SIGCONT and continue running.</div><div class="line">End!</div></pre></td></tr></table></figure>
<p>以上是suspend在脚本中的使用方法。另外，suspend默认不能在非loginshell中使用，如果使用，需要加-f参数。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>bash中也实现了基本的进程控制方法。主要的命令有exit，exec，logout，wait。其中exit我们已经了解了。logout的功能跟exit实际上差不多，区别只是logout是专门用来退出login方式的bash的。如果bash不是login方式执行的，logout会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat logout.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">logout</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./logout.sh </div><div class="line">./logout.sh: line 3: logout: not login shell: use `exit&apos;</div></pre></td></tr></table></figure>
<h3 id="wait："><a href="#wait：" class="headerlink" title="wait："></a>wait：</h3><p>wait命令的功能是用来等待jobs作业控制进程退出的。因为一般进程默认行为就是要等待其退出之后才能继续执行。wait可以等待指定的某个jobs进程，也可以等待所有jobs进程都退出之后再返回，实际上wait命令在bash脚本中是可以作为类似“屏障”这样的功能使用的。考虑这样一个场景，我们程序在运行到某一个阶段之后，需要并发的执行几个jobs，并且一定要等到这些jobs都完成工作才能继续执行，但是每个jobs的运行时间又不一定多久，此时，我们就可以用这样一个办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat wait.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;Begin:&quot;</div><div class="line"></div><div class="line">(sleep 3; echo 3) &amp;</div><div class="line">(sleep 5; echo 5) &amp;</div><div class="line">(sleep 7; echo 7) &amp;</div><div class="line">(sleep 9; echo 9) &amp;</div><div class="line"></div><div class="line">wait</div><div class="line"></div><div class="line">echo parent continue</div><div class="line"></div><div class="line">sleep 3</div><div class="line"></div><div class="line">echo end!</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./wait.sh </div><div class="line">Begin:</div><div class="line">3</div><div class="line">5</div><div class="line">7</div><div class="line">9</div><div class="line">parent continue</div><div class="line">end!</div></pre></td></tr></table></figure>
<p>通过这个例子可以看到wait的行为：在不加任何参数的情况下，wait会等到所有作业控制进程都退出之后再回返回，否则就会一直等待。当然，wait也可以指定只等待其中一个进程，可以指定pid和jobs方式的作业进程编号，如%3，就变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat wait.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;Begin:&quot;</div><div class="line"></div><div class="line">(sleep 3; echo 3) &amp;</div><div class="line">(sleep 5; echo 5) &amp;</div><div class="line">(sleep 7; echo 7) &amp;</div><div class="line">(sleep 9; echo 9) &amp;</div><div class="line"></div><div class="line">wait %3</div><div class="line"></div><div class="line">echo parent continue</div><div class="line"></div><div class="line">sleep 3</div><div class="line"></div><div class="line">echo end!</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./wait.sh </div><div class="line">Begin:</div><div class="line">3</div><div class="line">5</div><div class="line">7</div><div class="line">parent continue</div><div class="line">9</div><div class="line">end!</div></pre></td></tr></table></figure>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>我们已经在重定向那一部分讲过exec处理bash程序的文件描述符的使用方法了，在此补充一下它是如何执行命令的。这个命令的执行过程跟exec族的函数功能是一样的：将当前进程的执行镜像替换成指定进程的执行镜像。还是举例来看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat exec.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;Begin:&quot;</div><div class="line"></div><div class="line">echo &quot;Before exec:&quot;</div><div class="line"></div><div class="line">exec ls /etc/passwd</div><div class="line"></div><div class="line">echo &quot;After exec:&quot;</div><div class="line"></div><div class="line">echo &quot;End!&quot;</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./exec.sh </div><div class="line">Begin:</div><div class="line">Before exec:</div><div class="line">/etc/passwd</div></pre></td></tr></table></figure>
<p>实际上这个脚本在执行到exec ls /etc/passwd之后，bash进程就已经替换为ls进程了，所以后续的echo命令都不会执行，ls执行完，这个进程就完全退出了。</p>
<h2 id="命令行参数处理"><a href="#命令行参数处理" class="headerlink" title="命令行参数处理"></a>命令行参数处理</h2><p>我们已经学习过使用shift方式处理命令行参数了，但是这个功能还是比较简单，它每次执行就仅仅是将参数左移一位而已，将本次的$2变成下次的$1。bash也给我们提供了一个更为专业的命令行参数处理方法，这个命令是getopts。</p>
<p>我们都知道一般的命令参数都是通过-a、-b、-c这样的参数来指定各种功能的，如果我们想要实现这样的功能，只单纯使用shift这样的方式手工处理将会非常麻烦，而且还不能支持让-a -b写成-ab这样的方式。bash跟其他语言一样，提供了getopts这样的方法来帮助我们处理类似的问题，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat getopts.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#getopts的使用方式：字母后面带:的都是需要执行子参数的，如：-c xxxxx -e xxxxxx，后续可以用$OPTARG变量进行判断。</div><div class="line">#getopts会将输入的-a -b分别赋值给arg变量，以便后续判断。</div><div class="line">while getopts &quot;abc:de:f&quot; arg</div><div class="line">do</div><div class="line">    case $arg in</div><div class="line">        a)</div><div class="line">        echo &quot;aaaaaaaaaaaaaaa&quot;</div><div class="line">        ;;</div><div class="line">        b)</div><div class="line">        echo &quot;bbbbbbbbbbbbbbb&quot;</div><div class="line">        ;;</div><div class="line">        c)</div><div class="line">        echo &quot;c: arg:$OPTARG&quot;</div><div class="line">        ;;</div><div class="line">        d)</div><div class="line">        echo &quot;ddddddddddddddd&quot;</div><div class="line">        ;;</div><div class="line">        e)</div><div class="line">        echo &quot;e: arg:$OPTARG&quot;</div><div class="line">        ;;</div><div class="line">        f)</div><div class="line">        echo &quot;fffffffffffffff&quot;</div><div class="line">        ;;</div><div class="line">        ?)</div><div class="line">        echo &quot;$arg :no this arguments!&quot;</div><div class="line">    esac</div><div class="line">done</div></pre></td></tr></table></figure>
<p>以下为程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./getopts.sh -a -bd -c zorro -e jerry </div><div class="line">aaaaaaaaaaaaaaa</div><div class="line">bbbbbbbbbbbbbbb</div><div class="line">ddddddddddddddd</div><div class="line">c: arg:zorro</div><div class="line">e: arg:jerry</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./getopts.sh -c xxxxxxx</div><div class="line">c: arg:xxxxxxx</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./getopts.sh -a</div><div class="line">aaaaaaaaaaaaaaa</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./getopts.sh -f</div><div class="line">fffffffffffffff</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./getopts.sh -g</div><div class="line">./getopts.sh: illegal option -- g</div><div class="line">unknow argument!</div></pre></td></tr></table></figure>
<p>getopts只能处理段格式参数，如：-a这样的。不能支持的是如–login这种长格式参数。实际上我们的系统中还给了一个getopt命令，可以处理长格式参数。这个命令不是内建命令，使用方法跟getopts类似，大家可以自己man getopt近一步学习这个命令的使用，这里就不再赘述了。</p>
<h2 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h2><p>内建命令中最多的就是关于进程环境的配置的相关命令，当然绝大多数我们之前已经会用了。它们包括：alias、unalias、cd、declare、typeset、dirs、enable、export、hash、history、popd、pushd、local、pwd、readonly、set、unset、shopt、ulimit、umask。</p>
<p>我们在这需要简单说明的命令有：</p>
<p>declare：</p>
<p>typeset：</p>
<p>这两个命令用来声明或显示进程的变量或函数相关信息和属性。如：</p>
<p>declare -a array：可以声明一个数组变量。</p>
<p>declare -A array：可以声明一个关联数组。</p>
<p>declare -f func：可以声明或查看一个函数。</p>
<p>其他常用参数可以help declare查看。</p>
<p>enable：</p>
<p>可以用来打开或者关闭某个内建命令的功能。</p>
<p>dirs：</p>
<p>popd：</p>
<p>pushd：</p>
<p>dirs、popd、pushd可以用来操作目录栈。目录栈是bash提供的一种纪录曾经去过的相关目录的缓存数据结构，可以方便的使操作者在多个深层次的目录中方便的跳转。使用演示：</p>
<p>显示当前目录栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 dirstack]$ dirs</div><div class="line">~/bash/dirstack</div></pre></td></tr></table></figure>
<p>只有一个当前工作目录。将aaa加入目录栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 dirstack]$ pushd aaa</div><div class="line">~/bash/dirstack/aaa ~/bash/dirstack</div></pre></td></tr></table></figure>
<p>pushd除了将目录加入了目录栈外，还改变了当前工作目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 aaa]$ pwd</div><div class="line">/home/zorro/bash/dirstack/aaa</div></pre></td></tr></table></figure>
<p>将bbb目录加入目录栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 aaa]$ pushd ../bbb/</div><div class="line">~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack</div><div class="line">[zorro@zorrozou-pc0 bbb]$ dirs</div><div class="line">~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack</div><div class="line">[zorro@zorrozou-pc0 bbb]$ pwd</div><div class="line">/home/zorro/bash/dirstack/bbb</div></pre></td></tr></table></figure>
<p>加入ccc、ddd、eee目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bbb]$ pushd ../ccc</div><div class="line">~/bash/dirstack/ccc ~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack</div><div class="line">[zorro@zorrozou-pc0 ccc]$ pushd ../ddd</div><div class="line">~/bash/dirstack/ddd ~/bash/dirstack/ccc ~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack</div><div class="line">[zorro@zorrozou-pc0 ddd]$ pushd ../eee</div><div class="line">~/bash/dirstack/eee ~/bash/dirstack/ddd ~/bash/dirstack/ccc ~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack</div><div class="line">[zorro@zorrozou-pc0 eee]$ dirs</div><div class="line">~/bash/dirstack/eee ~/bash/dirstack/ddd ~/bash/dirstack/ccc ~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack</div></pre></td></tr></table></figure>
<p>将当前工作目录切换到目录栈中的第2个目录，即当前的ddd目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 eee]$ pushd +1</div><div class="line">~/bash/dirstack/ddd ~/bash/dirstack/ccc ~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack ~/bash/dirstack/eee</div></pre></td></tr></table></figure>
<p>将当前工作目录切换到目录栈中的第5个目录，即当前的~/bash/dirstack目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ddd]$ pushd +4</div><div class="line">~/bash/dirstack ~/bash/dirstack/eee ~/bash/dirstack/ddd ~/bash/dirstack/ccc ~/bash/dirstack/bbb ~/bash/dirstack/aaa</div></pre></td></tr></table></figure>
<p>+N表示当前目录栈从左往右数的第N个，第一个是左边的第一个目录，从0开始。<br>将当前工作目录切换到目录栈中的倒数第3个目录，即当前的ddd目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 dirstack]$ pushd -3</div><div class="line">~/bash/dirstack/ddd ~/bash/dirstack/ccc ~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack ~/bash/dirstack/eee</div></pre></td></tr></table></figure>
<p>-N表示当亲啊目录栈从右往左数的第N个，第一个是右边的第一个目录，从0开始。<br>从目录栈中推出一个目录，默认推出当前所在的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ccc]$ popd </div><div class="line">~/bash/dirstack/ddd ~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack ~/bash/dirstack/eee</div><div class="line">[zorro@zorrozou-pc0 ddd]$ popd </div><div class="line">~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack ~/bash/dirstack/eee</div></pre></td></tr></table></figure>
<p>指定要推出的目录编号，数字含义跟pushd一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bbb]$ popd +2</div><div class="line">~/bash/dirstack/bbb ~/bash/dirstack/aaa ~/bash/dirstack/eee</div><div class="line">[zorro@zorrozou-pc0 bbb]$ popd -2</div><div class="line">~/bash/dirstack/aaa ~/bash/dirstack/eee</div><div class="line">[zorro@zorrozou-pc0 aaa]$ pushd +1</div><div class="line">~/bash/dirstack/eee ~/bash/dirstack/aaa</div></pre></td></tr></table></figure>
<p>readonly：</p>
<p>声明一个只读变量。</p>
<p>local：</p>
<p>声明一个局部变量。bash的局部变量概念很简单，它只能在函数中使用，并且局部变量只有在函数中可见。</p>
<p>set：</p>
<p>shopt：</p>
<p>我们之前已经讲过这两个命令的使用。这里补充一下其他信息，请参见：<a href="http://www.cnblogs.com/ziyunfei/p/4913758.html" target="_blank" rel="external">http://www.cnblogs.com/ziyunfei/p/4913758.html</a></p>
<p>eval：</p>
<p>eval是一个可能会被经常用到的内建命令。它的作用其实很简单，就是将指定的命令解析两次。可以这样理解这个命令：</p>
<p>首先我们定义一个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ pipe=&quot;|&quot;</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $pipe</div><div class="line">|</div></pre></td></tr></table></figure>
<p>这个变量时pipe，值就是”|”这个字符。然后我们试图在后续命令中引入管道这个功能，但是管道符是从变量中引入的，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat /etc/passwd $pipe wc -l</div><div class="line">cat: invalid option -- &apos;l&apos;</div><div class="line">Try &apos;cat --help&apos; for more information.</div></pre></td></tr></table></figure>
<p>此时执行报错了，因为bash在解释这条命令的时候，并不会先将$pipe解析成”|”再做解释。这时候我们需要让bash先解析$pipe，然后得到”|”字符之后，再将cat /etc/passwd ｜ wc -l当成一个要执行的命令传给bash解释执行。此时我们需要eval：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">［zorro@zorrozou-pc0 bash]$ eval cat /etc/passwd $pipe wc -l</div><div class="line">30</div></pre></td></tr></table></figure>
<p>这就是eval的用法。再来理解一下，eval就是将所给的命令解析两遍。</p>
<p>最后</p>
<p>通过本文和之前的文章，我们几乎将所有的bash内建命令都覆盖到了。本文主要包括的知识点为：</p>
<ol>
<li>bash脚本程序的输入输出。</li>
<li>bash的作业控制。</li>
<li>bash脚本的信号处理。</li>
<li>bash对进程的控制。</li>
<li>命令行参数处理。</li>
<li>使用内建命令改变bash相关环境。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/08/shell-3/" title="SHELL编程之特殊符号" itemprop="url">SHELL编程之特殊符号</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-06-08T10:36:50.000Z" itemprop="datePublished"> Published 2016-06-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>文章转自<a href="http://liwei.life/2016/06/06/shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/" target="_blank" rel="external">SHELL编程之特殊符号</a></p>
<p>微博ID：<strong>orroz</strong></p>
<p>微信公众号：<strong>Linux系统技术</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是shell编程系列的第四篇，集中介绍了bash编程可能涉及到的特殊符号的使用。学会本文内容可以帮助你写出天书一样的bash脚本，并且顺便解决以下问题：</p>
<ul>
<li>输入输出重定向是什么原理？</li>
<li>exec 3&lt;&gt; /tmp/filename是什么鬼？</li>
<li>你玩过bash的关联数组吗？</li>
<li>如何不用if判断变量是否被定义？</li>
<li>脚本中字符串替换和删除操作不用sed怎么做？</li>
<li>” “和’ ‘有什么不同？</li>
<li>正则表达式和bash通配符是一回事么？</li>
</ul>
<p>这里需要额外注意的是，相同的符号出现在不同的上下文中可能会有不同的含义。我们会在后续的讲解中突出它们的区别。</p>
<h2 id="重定向-REDIRECTION"><a href="#重定向-REDIRECTION" class="headerlink" title="重定向(REDIRECTION)"></a>重定向(REDIRECTION)</h2><p>重定向也叫输入输出重定向。我们先通过基本的使用对这个概念有个感性认识。</p>
<h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><p>大家应该都用过cat命令，可以输出一个文件的内容。如：cat /etc/passwd。如果不给cat任何参数，那么cat将从键盘（标准输入）读取用户的输入，直接将内容显示到屏幕上，就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat</div><div class="line">hello </div><div class="line">hello</div><div class="line">I am zorro!</div><div class="line">I am zorro!</div></pre></td></tr></table></figure>
<p>可以通过输入重定向让cat命令从别的地方读取输入，显示到当前屏幕上。最简单的方式是输入重定向一个文件，不过这不够“神奇”，我们让cat从别的终端读取输入试试。我当前使用桌面的终端terminal开了多个bash，使用ps命令可以看到这些终端所占用的输入文件是哪个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ps ax|grep bash</div><div class="line"> 4632 pts/0    Ss     0:00 -bash</div><div class="line"> 5087 pts/2    S+     0:00 man bash</div><div class="line"> 5897 pts/1    Ss     0:00 -bash</div><div class="line"> 5911 pts/2    Ss     0:00 -bash</div><div class="line"> 9071 pts/4    Ss     0:00 -bash</div><div class="line">11667 pts/3    Ss+    0:00 -bash</div><div class="line">16309 pts/4    S+     0:00 grep --color=auto bash</div><div class="line">19465 pts/2    S      0:00 sudo bash</div><div class="line">19466 pts/2    S      0:00 bash</div></pre></td></tr></table></figure>
<p>通过第二列可以看到，不同的bash所在的终端文件是哪个，这里的pts/3就意味着这个文件放在/dev/pts/3。我们来试一下，在pts/2对应的bash中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat &lt; /dev/pts/3</div></pre></td></tr></table></figure>
<p>然后切换到pts/3所在的bash上敲入字符串，在pts/2的bash中能看见相关字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat &lt; /dev/pts/3 </div><div class="line">safsdfsfsfadsdsasdfsafadsadfd</div></pre></td></tr></table></figure>
<p>这只是个输入重定向的例子，一般我们也可以直接cat &lt; /etc/passwd，表示让cat命令不是从默认输入读取，而是从/etc/passwd读取，这就是输入重定向，使用”&lt;“。</p>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>绝大多数命令都有输出，用来显示给人看，所以输出基本都显示在屏幕（终端）上。有时候我们不想看到，就可以把输出重定向到别的地方：</p>
<p>[zorro@zorrozou-pc0 bash]$ ls /<br>bin  boot  cgroup  data  dev  etc  home  lib  lib64  lost+found  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>[zorro@zorrozou-pc0 bash]$ ls / &gt; /tmp/out<br>[zorro@zorrozou-pc0 bash]$ cat /tmp/out<br>bin<br>boot<br>cgroup<br>data<br>dev<br>……</p>
<p>使用一个”&gt;”，将原本显示在屏幕上的内容给输出到了/tmp/out文件中。这个功能就是输出重定向。</p>
<h3 id="报错重定向"><a href="#报错重定向" class="headerlink" title="报错重定向"></a>报错重定向</h3><p>命令执行都会遇到错误，一般也都是给人看的，所以默认还是显示在屏幕上。这些输出使用”&gt;”是不能进行重定向的：</p>
<p>[zorro@zorrozou-pc0 bash]$ ls /1234 &gt; /tmp/err<br>ls: cannot access ‘/1234’: No such file or directory</p>
<p>可以看到，报错还是显示在了屏幕上。如果想要重定向这样的内容，可以使用”2&gt;”：</p>
<p>[zorro@zorrozou-pc0 bash]$ ls /1234 2&gt; /tmp/err<br>[zorro@zorrozou-pc0 bash]$ cat /tmp/err<br>ls: cannot access ‘/1234’: No such file or directory</p>
<p>以上就是常见的输入输出重定向。在进行其它技巧讲解之前，我们有必要理解一下重定向的本质，所以要先从文件描述符说起。</p>
<h2 id="文件描述符-file-descriptor"><a href="#文件描述符-file-descriptor" class="headerlink" title="文件描述符(file descriptor)"></a>文件描述符(file descriptor)</h2><p>文件描述符简称fd，它是一个抽象概念，在很多其它体系下，它可能有其它名字，比如在C库编程中可以叫做文件流或文件流指针，在其它语言中也可以叫做文件句柄（handler），而且这些不同名词的隐含意义可能是不完全相同的。不过在系统层，还是应该使用系统调用中规定的名词，我们统一把它叫做文件描述符。</p>
<p>文件描述符本质上是一个数组下标（C语言数组）。在内核中，这个数组是用来管理一个进程打开的文件的对应关系的数组。就是说，对于任何一个进程来说，都有这样一个数组来管理它打开的文件，数组中的每一个元素和文件是映射关系，即：一个数组元素只能映射一个文件，而一个文件可以被多个数组元素所映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">其实上面的描述并不完全准确，在内核中，文件描述符的数组所直接映射的实际上是文件表，文件表再索引到相关文件的v_node。具体可以参见《UNIX系统高级编程》。</div></pre></td></tr></table></figure>
<p>shell在产生一个新进程后，新进程的前三个文件描述符都默认指向三个相关文件。这三个文件描述符对应的数组下标分别为0，1，2。0对应的文件叫做标准输入（stdin），1对应的文件叫做标准输出（stdout），2对应的文件叫做标准报错(stderr)。但是实际上，默认跟人交互的输入是键盘、鼠标，输出是显示器屏幕，这些硬件设备对于程序来说都是不认识的，所以操作系统借用了原来“终端”的概念，将键盘鼠标显示器都表现成一个终端文件。于是stdin、stdout和stderr就最重都指向了这所谓的终端文件上。于是，从键盘输入的内容，进程可以从标准输入的0号文件描述符读取，正常的输出内容从1号描述符写出，报错信息被定义为从2号描述符写出。这就是标准输入、标准输出和标准报错对应的描述符编号是0、1、2的原因。这也是为什么对报错进行重定向要使用2&gt;的原因(其实1&gt;也是可以用的)。</p>
<p>明白了以上内容之后，很多重定向的数字魔法就好理解了，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 prime]$ find /etc -name passwd &gt; /dev/null </div><div class="line">find: ‘/etc/docker’: Permission denied</div><div class="line">find: ‘/etc/sudoers.d’: Permission denied</div><div class="line">find: ‘/etc/lvm/cache’: Permission denied</div><div class="line">find: ‘/etc/pacman.d/gnupg/openpgp-revocs.d’: Permission denied</div><div class="line">find: ‘/etc/pacman.d/gnupg/private-keys-v1.d’: Permission denied</div><div class="line">find: ‘/etc/polkit-1/rules.d’: Permission denied</div></pre></td></tr></table></figure>
<p>这相当于只看报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 prime]$ find /etc -name passwd 2&gt; /dev/null </div><div class="line">/etc/default/passwd</div><div class="line">/etc/pam.d/passwd</div><div class="line">/etc/passwd</div></pre></td></tr></table></figure>
<p>这相当于只看正确输出信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 prime]$ find /etc -name passwd 2&gt;&amp;1</div><div class="line">/etc/default/passwd</div><div class="line">find: ‘/etc/docker’: Permission denied</div><div class="line">/etc/pam.d/passwd</div><div class="line">find: ‘/etc/sudoers.d’: Permission denied</div><div class="line">find: ‘/etc/lvm/cache’: Permission denied</div><div class="line">find: ‘/etc/pacman.d/gnupg/openpgp-revocs.d’: Permission denied</div><div class="line">find: ‘/etc/pacman.d/gnupg/private-keys-v1.d’: Permission denied</div><div class="line">find: ‘/etc/polkit-1/rules.d’: Permission denied</div><div class="line">/etc/passwd</div></pre></td></tr></table></figure>
<p>将标准报错输出的，重定向到标准输出再输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 prime]$ echo hello &gt; /tmp/out </div><div class="line">[zorro@zorrozou-pc0 prime]$ cat /tmp/out</div><div class="line">hello</div><div class="line">[zorro@zorrozou-pc0 prime]$ echo hello2 &gt;&gt; /tmp/out </div><div class="line">[zorro@zorrozou-pc0 prime]$ cat /tmp/out</div><div class="line">hello</div><div class="line">hello2</div></pre></td></tr></table></figure>
<p>“&gt;&gt;”表示追加重定向。</p>
<p>相信大家对&amp;&gt;&gt;、1&gt;&amp;2、？2&gt;&amp;3、6&gt;&amp;8、&gt;&gt;file 2&gt;&amp;1这样的写法应该也都能理解了。进程可以打开多个文件，多个描述符之间都可以进行重定向。当然，输入也可以，比如：3&lt;表示从描述符3读取。下面我们罗列一下其他重定向符号和用法：</p>
<p><strong>Here Document：</strong></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;[-]word</div><div class="line">    here-document</div><div class="line">delimiter</div></pre></td></tr></table></figure>
<p>这是一种特殊的输入重定向，重定向的内容并不是来自于某个文件，而是从当前输入读取，直到输入中写入了delimiter字符标记结束。用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 prime]$ cat &lt;&lt; EOF</div><div class="line">&gt; hello world!</div><div class="line">&gt; I am zorro</div><div class="line">&gt; </div><div class="line">&gt; </div><div class="line">&gt; </div><div class="line">&gt; sadfsdf</div><div class="line">&gt; ertert</div><div class="line">&gt; eof</div><div class="line">&gt; EOF</div><div class="line">hello world!</div><div class="line">I am zorro</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">sadfsdf</div><div class="line">ertert</div><div class="line">eof</div></pre></td></tr></table></figure>
<p>这个例子可以看到，最后cat输出的内容都是在上面写入的内容，而且内容中不包括EOF，因为EOF是标记输入结束的字符串。这个功能在脚本中通常可以用于需要交互式处理的某些命令的输入和文件编辑，比如想在脚本中使用fdisk命令新建一个分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 prime]# cat fdisk.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">fdisk /dev/sdb &lt;&lt; EOF</div><div class="line">n</div><div class="line">p</div><div class="line"></div><div class="line"></div><div class="line">w</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>当然这个脚本大家千万不要乱执行，可能会修改你的分区表。其中要输入的内容，相信熟悉fdisk命令的人应该都能明白，我就不多解释了。</p>
<p><strong> Here strings： </strong></p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;&lt;word</div></pre></td></tr></table></figure>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 prime]$ cat &lt;&lt;&lt; asdasdasd</div><div class="line">asdasdasd</div></pre></td></tr></table></figure>
<p>其实就是将&lt;&lt;&lt;符号后面的字符串当成要输入的内容给cat，而不是定向一个文件描述符。这样是不是就相当于把cat当echo用了？</p>
<p>文件描述符的复制：</p>
<p>复制输入文件描述符：[n]&lt;&amp;word</p>
<p>如果n没有指定数字，则默认复制0号文件描述符。word一般写一个已经打开的并且用来作为输入的描述符数字，表示将制订的n号描述符在制定的描述符上复制一个。如果word写的是“-”符号，则表示关闭这个文件描述符。如果word指定的不是一个用来输入的文件描述符，则会报错。</p>
<p>复制输出文件描述符：[n]&gt;&amp;word</p>
<p>复制一个输出的描述符，字段描述参考上面的输入复制，例子上面已经讲过了。这里还需要知道的就是1&gt;&amp;-表示关闭1号描述符。</p>
<p><strong>文件描述符的移动</strong>：</p>
<p>移动输入描述符：[n]&lt;&amp;digit-</p>
<p>移动输出描述符：[n]&gt;&amp;digit-</p>
<p>这两个符号的意思都是将原有描述符在新的描述符编号上打开，并且关闭原有描述符。</p>
<p>描述符新建：</p>
<p>新建一个用来输入的描述符：[n]&lt;word</p>
<p>新建一个用来输出的描述符：[n]&gt;word</p>
<p>新建一个用来输入和输出的描述符：[n]&lt;&gt;word</p>
<p>word都应该写一个文件路径，用来表示这个文件描述符的关联文件是谁。</p>
<p>下面我们来看相关的编程例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line"># example 1</div><div class="line">#打开3号fd用来输入，关联文件为/etc/passwd</div><div class="line">exec 3&lt; /etc/passwd</div><div class="line">#让3号描述符成为标准输入</div><div class="line">exec 0&lt;&amp;3</div><div class="line">#此时cat的输入将是/etc/passwd，会在屏幕上显示出/etc/passwd的内容。</div><div class="line">cat</div><div class="line"></div><div class="line">#关闭3号描述符。</div><div class="line">exec 3&gt;&amp;-</div><div class="line"></div><div class="line"># example 2</div><div class="line">#打开3号和4号描述符作为输出，并且分别关联文件。</div><div class="line">exec 3&gt; /tmp/stdout</div><div class="line"></div><div class="line">exec 4&gt; /tmp/stderr</div><div class="line"></div><div class="line">#将标准输入关联到3号描述符，关闭原来的1号fd。</div><div class="line">exec 1&gt;&amp;3-</div><div class="line">#将标准报错关联到4号描述符，关闭原来的2号fd。</div><div class="line">exec 2&gt;&amp;4-</div><div class="line"></div><div class="line">#这个find命令的所有正常输出都会写到/tmp/stdout文件中，错误输出都会写到/tmp/stderr文件中。</div><div class="line">find /etc/ -name &quot;passwd&quot;</div><div class="line"></div><div class="line">#关闭两个描述符。</div><div class="line">exec 3&gt;&amp;-</div><div class="line">exec 4&gt;&amp;-</div></pre></td></tr></table></figure>
<p>以上脚本要注意的地方是，一般输入输出重定向都是放到命令后面作为后缀使用，所以如果单纯改变脚本的描述符，需要在前面加exec命令。这种用法也叫做描述符魔术。某些特殊符号还有一些特殊用法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zorro@zorrozou-pc0 bash]$ &gt; /tmp/out</div></pre></td></tr></table></figure>
<p>表示清空文件，当然也可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ :&gt; /tmp/out</div></pre></td></tr></table></figure>
<p>因为”:”是一个内建命令，跟true是同样的功能，所以没有任何输出，所以这个命令清空文件的作用。</p>
<h2 id="脚本参数处理"><a href="#脚本参数处理" class="headerlink" title="脚本参数处理"></a>脚本参数处理</h2><p>我们在之前的例子中已经简单看过相关参数处理的特殊符号了，再来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat arg1.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo $0</div><div class="line">echo $1</div><div class="line">echo $2</div><div class="line">echo $3</div><div class="line">echo $4</div><div class="line">echo $#</div><div class="line">echo $*</div><div class="line">echo $?</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./arg1.sh 111 222 333 444</div><div class="line">./arg1.sh</div><div class="line">111</div><div class="line">222</div><div class="line">333</div><div class="line">444</div><div class="line">4</div><div class="line">111 222 333 444</div><div class="line">0</div></pre></td></tr></table></figure>
<p>可以罗列一下：</p>
<p>$0：命令名。</p>
<p>$n：n是一个数字，表示第n个参数。</p>
<p>$#：参数个数。</p>
<p>$*：所有参数列表。</p>
<p>$@：同上。</p>
<p>实际上大家可以认为上面的0,1,2,3,#,*,@,?都是一堆变量名。跟aaa＝1000定义的变量没什么区别，只是他们有特殊含义。所以$@实际上就是对@变量取值，跟$aaa概念一样。所以上述所有取值都可以写成${}的方式，因为bash中对变量取值有两种写法，另外一种是${aaa}。这种写法的好处是对变量名字可以有更明确的界定，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ aaa=1000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa0</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa&#125;0</div><div class="line">10000</div></pre></td></tr></table></figure>
<p>内建命令shift可以用来对参数进行位置处理，它会将所有参数都左移一个位置，可以用来进行参数处理。使用例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ cat shift.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">if [ $# -lt 1 ]</div><div class="line">then</div><div class="line">    echo &quot;Argument num error!&quot; 1&gt;&amp;2</div><div class="line">    echo &quot;Usage .....&quot; 1&gt;&amp;2</div><div class="line">    exit</div><div class="line">fi</div><div class="line"></div><div class="line">while ! [ -z $1 ]</div><div class="line">do</div><div class="line">    echo $1</div><div class="line">    shift</div><div class="line">done</div></pre></td></tr></table></figure>
<p>执行效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./shift.sh 111 222 333 444 555 666</div><div class="line">111</div><div class="line">222</div><div class="line">333</div><div class="line">444</div><div class="line">555</div><div class="line">666</div></pre></td></tr></table></figure>
<p>其他的特殊变量还有：</p>
<p>$?：上一个命令的返回值。</p>
<p>$$：当前shell的PID。</p>
<p>$!：最近一个被放到后台任务管理的进程PID。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 tmp]$ sleep 3000 &amp;</div><div class="line">[1] 867</div><div class="line">[zorro@zorrozou-pc0 tmp]$ echo $!</div><div class="line">867</div></pre></td></tr></table></figure>
<p>$-：列出当前bash的运行参数，比如set -v或者-i这样的参数。</p>
<p>$：”“算是所有特殊变量中最诡异的一个了，在bash脚本刚开始的时候，它可以取到脚本的完整文件名。当执行完某个命令之后，它可以取到，这个命令的最后一个参数。当在检查邮件的时候，这个变量帮你保存当前正在查看的邮件名。</p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><p>bash中可以定义数组，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat array.sh</div><div class="line">#!/bin/bash</div><div class="line">#定义一个一般数组</div><div class="line">declare -a array</div><div class="line"></div><div class="line">#为数组元素赋值</div><div class="line">array[0]=1000</div><div class="line">array[1]=2000</div><div class="line">array[2]=3000</div><div class="line">array[3]=4000</div><div class="line"></div><div class="line">#直接使用数组名得出第一个元素的值</div><div class="line">echo $array</div><div class="line">#取数组所有元素的值</div><div class="line">echo $&#123;array[*]&#125;</div><div class="line">echo $&#123;array[@]&#125;</div><div class="line">#取第n个元素的值</div><div class="line">echo $&#123;array[0]&#125;</div><div class="line">echo $&#123;array[1]&#125;</div><div class="line">echo $&#123;array[2]&#125;</div><div class="line">echo $&#123;array[3]&#125;</div><div class="line">#数组元素个数</div><div class="line">echo $&#123;#array[*]&#125;</div><div class="line">#取数组所有索引列表</div><div class="line">echo $&#123;!array[*]&#125;</div><div class="line">echo $&#123;!array[@]&#125;</div><div class="line"></div><div class="line">#定义一个关联数组</div><div class="line">declare -A assoc_arr</div><div class="line"></div><div class="line">#为关联数组复制</div><div class="line">assoc_arr[zorro]=&apos;zorro&apos;</div><div class="line">assoc_arr[jerry]=&apos;jerry&apos;</div><div class="line">assoc_arr[tom]=&apos;tom&apos;</div><div class="line"></div><div class="line">#所有操作同上</div><div class="line">echo $assoc_arr</div><div class="line">echo $&#123;assoc_arr[*]&#125;</div><div class="line">echo $&#123;assoc_arr[@]&#125;</div><div class="line">echo $&#123;assoc_arr[zorro]&#125;</div><div class="line">echo $&#123;assoc_arr[jerry]&#125;</div><div class="line">echo $&#123;assoc_arr[tom]&#125;</div><div class="line">echo $&#123;#assoc_arr[*]&#125;</div><div class="line">echo $&#123;!assoc_arr[*]&#125;</div><div class="line">echo $&#123;!assoc_arr[@]&#125;</div></pre></td></tr></table></figure>
<h2 id="命令行扩展"><a href="#命令行扩展" class="headerlink" title="命令行扩展"></a>命令行扩展</h2><h3 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h3><p>用类似枚举的方式创建一些目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ mkdir -p test/zorro/&#123;a,b,c,d&#125;&#123;1,2,3,4&#125;</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls test/zorro/</div><div class="line">a1  a2  a3  a4  b1  b2  b3  b4  c1  c2  c3  c4  d1  d2  d3  d4</div></pre></td></tr></table></figure>
<p>可能还有这样用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ mv test/&#123;a,c&#125;.conf</div></pre></td></tr></table></figure>
<p>这个命令的意思是：mv test/a.conf test/c.conf</p>
<h2 id="符号扩展"><a href="#符号扩展" class="headerlink" title="~符号扩展"></a>~符号扩展</h2><p>～：在bash中一般表示用户的主目录。cd ~表示回到主目录。cd ~zorro表示回到zorro用户的主目录。<br>变量扩展</p>
<p>我们都知道取一个变量值可以用$或者${}。在使用${}的时候可以添加很多对变量进行扩展操作的功能，下面我们就分别来看看。</p>
<p><code>${aaa:-1000}</code></p>
<p>这个表示如果变量aaa是空值或者没有赋值，则此表达式取值为1000，aaa变量不被更改，以后还是空。如果aaa已经被赋值，则原值不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:-1000&#125;</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">[zorro@zorrozou-pc0 bash]$ aaa=2000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">2000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:-1000&#125;</div><div class="line">2000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">2000</div></pre></td></tr></table></figure>
<p><code>${aaa:=1000}</code></p>
<p>跟上面的表达式的区别是，如果aaa未被赋值，则赋值成＝后面的值，其他行为不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:=1000&#125;</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">1000</div></pre></td></tr></table></figure>
<p><code>${aaa:?unset}</code></p>
<p>判断变量是否未定义或为空，如果符合条件，就提示？后面的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:?unset&#125;</div><div class="line">-bash: aaa: unset</div><div class="line">[zorro@zorrozou-pc0 bash]$ aaa=1000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:?unset&#125;</div><div class="line">1000</div></pre></td></tr></table></figure>
<p><code>${aaa:+unset}</code></p>
<p>如果aaa为空或者未设置，则什么也不做。如果已被设置，则取+后面的值。并不改变原aaa值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ aaa=1000</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:+unset&#125;</div><div class="line">unset</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">1000</div></pre></td></tr></table></figure>
<p><code>${aaa:10}</code></p>
<p>取字符串偏移量，表示取出aaa变量对应字符串的第10个字符之后的字符串，变量原值不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ aaa=&apos;/home/zorro/zorro.txt&apos;</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:10&#125;</div><div class="line">o/zorro.txt</div></pre></td></tr></table></figure>
<p><code>${aaa:10:15}</code></p>
<p>第二个数字表示取多长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa:10:5&#125;</div><div class="line">o/zor</div></pre></td></tr></table></figure>
<p><code>${!B*}</code></p>
<p><code>${!B@}</code></p>
<p>取出所有以B开头的变量名（请注意他们跟数组中相关符号的差别）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;!B*&#125;</div><div class="line">BASH BASHOPTS BASHPID BASH_ALIASES BASH_ARGC BASH_ARGV BASH_CMDS BASH_COMMAND BASH_LINENO BASH_SOURCE BASH_SUBSHELL BASH_VERSINFO BASH_VERSION</div></pre></td></tr></table></figure>
<p><code>${ #aaa }</code><br>取变量长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;#aaa&#125;</div><div class="line">21</div></pre></td></tr></table></figure>
<p><code>${ parameter#word}</code></p>
<p>变量paramenter看做字符串从左往右找到第一个word，取其后面的字串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa#/&#125;</div><div class="line">home/zorro/zorro.txt</div></pre></td></tr></table></figure>
<p>这里需要注意的是，word必须是一个路径匹配的字符串，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa#*zorro&#125;</div><div class="line">/zorro.txt</div></pre></td></tr></table></figure>
<p>这个表示删除路径中匹配到的第一个zorro左边的所有字符，而这样是无效的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa#zorro&#125;</div><div class="line">/home/zorro/zorro.txt</div></pre></td></tr></table></figure>
<p>因为此时zorro不是一个路径匹配。另外，这个表达式只能删除匹配到的左边的字符串，保留右边的。</p>
<p><code>${ parameter##word}</code></p>
<p>这个表达式与上一个的区别是，匹配的不是第一个符合条件的word，而是最后一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa##*zorro&#125;</div><div class="line">.txt</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa##*/&#125;</div><div class="line">zorro.txt</div></pre></td></tr></table></figure>
<p><code>${ parameter%word}</code><br><code>${ parameter%%word}</code></p>
<p>这两个符号相对于上面两个相当于#号换成了%号，操作区别也从匹配删除左边的字符变成了匹配删除右边的字符，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa%/*&#125;</div><div class="line">/home/zorro</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa%t&#125;</div><div class="line">/home/zorro/zorro.tx</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa%.*&#125;</div><div class="line">/home/zorro/zorro</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa%%z*&#125;</div><div class="line">/home/</div></pre></td></tr></table></figure>
<p>以上#号和%号分别是匹配删除哪边的，容易记不住。不过有个窍门是，可以看看他们分别在键盘上的$的哪边？在左边的就是匹配删除左边的，在右边就是匹配删除右边的。</p>
<p><code>${ parameter/pattern/string}</code></p>
<p>字符串替换，将pattern匹配到的第一个字符串替换成string，pattern可以使用通配符，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $aaa</div><div class="line">/home/zorro/zorro.txt</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa/zorro/jerry&#125;</div><div class="line">/home/jerry/zorro.txt</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa/zorr?/jerry&#125;</div><div class="line">/home/jerry/zorro.txt</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa/zorr*/jerry&#125;</div><div class="line">/home/jerry</div></pre></td></tr></table></figure>
<p><code>${ parameter//pattern/string}</code></p>
<p>意义同上，不过变成了全局替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $&#123;aaa//zorro/jerry&#125;</div><div class="line">/home/jerry/jerry.txt</div></pre></td></tr></table></figure>
<p>${parameter^pattern}<br>${parameter^^pattern}<br>${parameter,pattern}<br>${parameter,,pattern}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">大小写转换，如：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ echo $aaa<br>abcdefg<br>[zorro@zorrozou-pc0 bash]$ echo ${aaa^}<br>Abcdefg<br>[zorro@zorrozou-pc0 bash]$ echo ${aaa^^}<br>ABCDEFG<br>[zorro@zorrozou-pc0 bash]$ aaa=ABCDEFG<br>[zorro@zorrozou-pc0 bash]$ echo ${aaa,}<br>aBCDEFG<br>[zorro@zorrozou-pc0 bash]$ echo ${aaa,,}<br>abcdefg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">有了以上符号后，很多变量内容的处理就不必再使用sed这样的重型外部命令处理了，可以一定程度的提高bash脚本的执行效率。</div><div class="line"></div><div class="line">### 命令置换</div><div class="line"></div><div class="line">命令置换这个概念就是在命令行中引用一个命令的输出给bash执行，就是我们已经用过的符号，如：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ echo ls<br>ls<br>[zorro@zorrozou-pc0 bash]$ <code>echo ls</code><br>3 arg1.sh array.sh auth_if.sh cat.sh for2.sh hash.sh name.sh ping.sh redirect.sh shift.sh until.sh<br>alias.sh arg.sh auth_case.sh case.sh exit.sh for.sh if_1.sh na.sh prime select.sh test while.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">bash会执行放在号中的命令，并将其输出作为bash的命令再执行一遍。在某些情况下双反引号的表达能力有欠缺，比如嵌套的时候就分不清到底是谁嵌套谁？所以bash还提供另一种写法，跟这个符号一样就是$()。</div><div class="line"></div><div class="line">### 算数扩展</div><div class="line"></div><div class="line">$(())</div><div class="line"></div><div class="line">$[]</div><div class="line"></div><div class="line">绝大多数算是表达式可以放在$(())和$[]中进行取值，如：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ echo $((123+345))<br>468<br>[zorro@zorrozou-pc0 bash]$<br>[zorro@zorrozou-pc0 bash]$<br>[zorro@zorrozou-pc0 bash]$ echo $((345-123))<br>222<br>[zorro@zorrozou-pc0 bash]$ echo $((345*123))<br>42435<br>[zorro@zorrozou-pc0 bash]$ echo $((345/123))<br>2<br>[zorro@zorrozou-pc0 bash]$ echo $((345%123))<br>99<br>[zorro@zorrozou-pc0 bash]$ i=1<br>[zorro@zorrozou-pc0 bash]$ echo $((i++))<br>1<br>[zorro@zorrozou-pc0 bash]$ echo $((i++))<br>2<br>[zorro@zorrozou-pc0 bash]$ echo $i<br>3<br>[zorro@zorrozou-pc0 bash]$ i=1<br>[zorro@zorrozou-pc0 bash]$ echo $((++i))<br>2<br>[zorro@zorrozou-pc0 bash]$ echo $((++i))<br>3<br>[zorro@zorrozou-pc0 bash]$ echo $i<br>3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以支持的运算符包括：</div></pre></td></tr></table></figure></p>
<p>   id++ id–</p>
<p>   ++id –id</p>
<ul>
<li><ul>
<li>! ~<br>**     </li>
</ul>
</li>
</ul>
<ul>
<li>/ %  </li>
</ul>
<ul>
<li><ul>
<li>&lt;&lt; &gt;&gt;<br>&lt;= &gt;= &lt; &gt;</li>
</ul>
<p>== !=<br>&amp;<br>^<br>|<br>&amp;&amp;<br>||<br>expr?expr:expr<br>= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">另外可以进行算数运算的还有内建命令let：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>[zorro@zorrozou-pc0 bash]$ i=0<br>[zorro@zorrozou-pc0 bash]$ let ++i<br>[zorro@zorrozou-pc0 bash]$ echo $i<br>1<br>[zorro@zorrozou-pc0 bash]$ i=2<br>[zorro@zorrozou-pc0 bash]$ let i=i**2<br>[zorro@zorrozou-pc0 bash]$ echo $i<br>4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let的另外一种写法是(()):</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ i=0<br>[zorro@zorrozou-pc0 bash]$ ((i++))<br>[zorro@zorrozou-pc0 bash]$ echo $i<br>1<br>[zorro@zorrozou-pc0 bash]$ ((i+=4))<br>[zorro@zorrozou-pc0 bash]$ echo $i<br>5<br>[zorro@zorrozou-pc0 bash]$ ((i=i**7))<br>[zorro@zorrozou-pc0 bash]$ echo $i<br>78125<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 进程置换</div><div class="line"></div><div class="line">&lt;(list) 和 &gt;(list)</div><div class="line"></div><div class="line">这两个符号可以将list的执行结果当成别的命令需要输入或者输出的文件进行操作，比如我想比较两个命令执行结果的区别：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ diff &lt;(df -h) &lt;(df)<br>1,10c1,10<br>&lt; Filesystem               Size  Used Avail Use% Mounted on<br>&lt; dev                      7.8G     0  7.8G   0% /dev<br>&lt; run                      7.9G  1.1M  7.8G   1% /run<br>&lt; /dev/sda3                 27G   13G   13G  50% /<br>&lt; tmpfs                    7.9G  500K  7.8G   1% /dev/shm<br>&lt; tmpfs                    7.9G     0  7.9G   0% /sys/fs/cgroup<br>&lt; tmpfs                    7.9G  112K  7.8G   1% /tmp<br>&lt; /dev/mapper/fedora-home   99G   76G   18G  82% /home<br>&lt; tmpfs                    1.6G   16K  1.6G   1% /run/user/120</p>
<h2 id="lt-tmpfs-1-6G-16K-1-6G-1-run-user-1000"><a href="#lt-tmpfs-1-6G-16K-1-6G-1-run-user-1000" class="headerlink" title="&lt; tmpfs                    1.6G   16K  1.6G   1% /run/user/1000"></a>&lt; tmpfs                    1.6G   16K  1.6G   1% /run/user/1000</h2><blockquote>
<p>Filesystem              1K-blocks     Used Available Use% Mounted on<br>dev                       8176372        0   8176372   0% /dev<br>run                       8178968     1052   8177916   1% /run<br>/dev/sda3                28071076 13202040  13420028  50% /<br>tmpfs                     8178968      500   8178468   1% /dev/shm<br>tmpfs                     8178968        0   8178968   0% /sys/fs/cgroup<br>tmpfs                     8178968      112   8178856   1% /tmp<br>/dev/mapper/fedora-home 103081248 79381728  18440256  82% /home<br>tmpfs                     1635796       16   1635780   1% /run/user/120<br>tmpfs                     1635796       16   1635780   1% /run/user/1000</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">这个符号会将相关命令的输出放到/dev/fd中创建的一个管道文件中，并将管道文件作为参数传递给相关命令进行处理。</div><div class="line"></div><div class="line">### 路径匹配扩展</div><div class="line"></div><div class="line">我们已经知道了路径文件名匹配中的*、?、［abc］这样的符号。bash还给我们提供了一些扩展功能的匹配，需要先使用内建命令shopt打开功能开关。支持的功能有：</div></pre></td></tr></table></figure>
<p>?(pattern-list)：匹配所给pattern的0次或1次；<br>*(pattern-list)：匹配所给pattern的0次以上包括0次；<br>+(pattern-list)：匹配所给pattern的1次以上包括1次；<br>@(pattern-list)：匹配所给pattern的1次；<br>!(pattern-list)：匹配非括号内的所给pattern。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用：</div></pre></td></tr></table></figure>
<p>[zorro@zorrozou-pc0 bash]$ shopt -u extglob<br>[zorro@zorrozou-pc0 bash]$ ls /etc/<em>(</em>a)<br>/etc/netdata:<br>apps_groups.conf  charts.d.conf  netdata.conf</p>
<p>/etc/pcmcia:<br>config.opts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">关闭功能之后不能使用：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ shopt -u extglob<br>[zorro@zorrozou-pc0 bash]$ ls /etc/<em>(</em>a)<br>-bash: syntax error near unexpected token `(‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 其他常用符号</div><div class="line"></div><div class="line">关键字或保留字是一类特殊符号或者单词，它们具有相同的实现属性，即：使用type命令查看其类型都显示key word。</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ type !<br>! is a shell keyword<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">!：当只出现一个叹号的时候代表对表达式（命令的返回值）取非。如：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ echo hello<br>hello<br>[zorro@zorrozou-pc0 bash]$ echo $?<br>0<br>[zorro@zorrozou-pc0 bash]$ ! echo hello<br>hello<br>[zorro@zorrozou-pc0 bash]$ echo $?<br>1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[[]]：这个符号基本跟内建命令test一样，当然我们也知道，内建命令test的另一种写法是[ ]。使用：</div></pre></td></tr></table></figure></p>
<p>[root@zorrozou-pc0 zorro]# [[ -f /etc/passwd ]]<br>[root@zorrozou-pc0 zorro]# echo $?<br>0<br>[root@zorrozou-pc0 zorro]# [[ -f /etc/pass ]]<br>[root@zorrozou-pc0 zorro]# echo $?<br>1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">可以支持的判断参数可以help test查看。</div><div class="line"></div><div class="line">管道”|”或|&amp;：管道其实有两种写法，但是我们一般只常用其中单竖线一种。使用的语法格式：</div><div class="line"></div><div class="line">command1 [ [|⎪|&amp;] command2 ... ]</div><div class="line">管道“｜”的主要作用是将command1的标准输出跟command2的标准输入通过管道(pipe)连接起来。“|&amp;”这种写法的含义是将command1标准输出和标准报错都跟command2的和准输入连接起来，这相当于是command1 2&gt;&amp;1 | command2的简写方式。</div><div class="line"></div><div class="line">&amp;&amp;：用逻辑与关系连接两个命令，如：command1 &amp;&amp; command2，表示当command1执行成功才执行command2，否则command2不会执行。</div><div class="line"></div><div class="line">||：用逻辑或关系连接两个命令，如：command1 || command2，表示当command1执行不成功才执行command2，否则command2不会执行。</div><div class="line"></div><div class="line">有了这两个符号，很多if判断都不用写了。</div><div class="line"></div><div class="line">&amp;：一般作为一个命令或者lists的后缀，表明这个命令的执放到jobs中跑，bash不必wait进程。</div><div class="line"></div><div class="line">;：作为命令或者lists的后缀，主要起到分隔多个命令用的，效果跟回车是一样的。</div><div class="line"></div><div class="line">(list)：放在()中执行的命令将在一个subshell环境中执行，这样的命令将打开一个bash子进程执行。即使要执行的是内建命令，也要打开一个subshell的子进程。另外要注意的是，当内建命令前后有管道符号连接的时候，内建命令本身也是要放在subshell中执行的。这个subshell子进程的执行环境基本上是父进程的复制，除了重置了信号的相关设置。bash编程的信号设置使用内建命令trap，将在后续文章中详细说明。</div><div class="line"></div><div class="line">&#123; list; &#125;：大括号作为函数语法结构中的标记字段和list标记字段，是一个关键字。在大括号中要执行的命令列表（list）会放在当前执行环境中执行。命令列表必须以一个换行或者分号作为标记结束。</div><div class="line"></div><div class="line">## 转义字符</div><div class="line"></div><div class="line">转义字符很重要，所以需要单独拿出来重点说一下。既然bash给我们提供了这么多的特殊字符，那么这些字符对于bash来说就是需要进行特殊处理的。比如我们想创建一个文件名中包含*的文件：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ ls<br>3         arg1.sh  array.sh      auth_if.sh  cat.sh   for2.sh  hash.sh  name.sh  ping.sh  read.sh      select.sh  test      while.sh<br>alias.sh  arg.sh   auth_case.sh  case.sh     exit.sh  for.sh   if_1.sh  na.sh    prime    redirect.sh  shift.sh   until.sh<br>[zorro@zorrozou-pc0 bash]$ touch *sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这个命令会被bash转义成，对所有文件名以sh结尾的文件做touch操作。那究竟怎么创建这个文件呢？使用转义符：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ touch *sh<br>[zorro@zorrozou-pc0 bash]$ ls<br>3         arg1.sh  array.sh      auth_if.sh  cat.sh   for2.sh  hash.sh  name.sh  ping.sh  read.sh      select.sh  shift.sh  until.sh<br>alias.sh  arg.sh   auth_case.sh  case.sh     exit.sh  for.sh   if_1.sh  na.sh    prime    redirect.sh  ‘*sh’      test      while.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">创建了一个叫做*sh的文件，\就是转义符，它可以转义后面的一个字符。如果我想创建一个名字叫\的文件，就应该：</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ touch \<br>[zorro@zorrozou-pc0 bash]$ ls<br>‘\’  alias.sh  arg.sh    auth_case.sh  case.sh  exit.sh  for.sh   if_1.sh  na.sh    prime    redirect.sh  ‘*sh’     test      while.sh<br>3    arg1.sh   array.sh  auth_if.sh    cat.sh   for2.sh  hash.sh  name.sh  ping.sh  read.sh  select.sh    shift.sh  until.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如何删除sh呢？rm sh？注意到了么？一不小心就会误操作！正确的做法是:</div></pre></td></tr></table></figure></p>
<p>[zorro@zorrozou-pc0 bash]$ rm *sh<br>```</p>
<p>可以成功避免这种误操作的习惯是，不要用特殊字符作为文件名或者目录名，不要给自己犯错误的机会！</p>
<p>另外”也是非常重要的转义字符，\只能转义其后面的一个字符，而”可以转义其扩起来的所有字符。另外””也能起到一部分的转义作用，只是它的转义能力没有”强。”和<br>“”的区别是：”可以转义所有字符，而””不能对$字符、命令置换“和\转义字符进行转义。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>先补充一个关于正则表达式的说明：</p>
<p>很多初学者容易将bash的特殊字符和正则表达式搞混，尤其是*、?、[]这些符号。实际上我们要明白，正则表达式跟bash的通配符和特殊符号没有任何关系。bash本身并不支持正则表达式。那些支持正在表达式的都是外部命令，比如grep、sed、awk这些高级文件处理命令。正则表达式是由这些命令自行处理的，而bash并不对正则表达式做任何解析和解释。</p>
<p>关于正则表达式的话题，我们就不在bash编程系列文章中讲解了，不过未来可能会在讲解sed、awk这样的高级文本处理命令中说明。</p>
<p>通过本文我们学习了bash的特殊符号相关内容，主要包括的知识点为：</p>
<ol>
<li>输入输出重定向以及描述符魔术。</li>
<li>bash脚本的命令行参数处理。</li>
<li>bash脚本的数组和关联数组。</li>
<li>bash的各种其他扩展特殊字符操作。</li>
<li>转义字符介绍。</li>
<li>正则表达式和bash特殊字符的区别。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/shell/">shell</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/08/shell-2/" title="shell编程之执行环境" itemprop="url">shell编程之执行环境</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-06-08T08:36:50.000Z" itemprop="datePublished"> Published 2016-06-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>文章转自<a href="http://liwei.life/2016/05/30/shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/" target="_blank" rel="external">SHELL编程之执行环境</a></p>
<p>微博ID：<strong>orroz</strong></p>
<p>微信公众号：<strong>Linux系统技术</strong></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是shell编程系列的第三篇，主要介绍bash脚本的执行环境以及注意事项。通过本文，应该可以帮助您解决以下问题：</p>
<ul>
<li>执行bash和执行sh究竟有什么区别？</li>
<li>如何调试bash脚本？</li>
<li>如何记录用户在什么时候执行的某条命令？</li>
<li>为什么有时ulimit命令的设置不生效或者报错？</li>
<li>环境变量和一般变量有什么区别？？</li>
</ul>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><h3 id="交互式login-shell"><a href="#交互式login-shell" class="headerlink" title="交互式login shell"></a>交互式login shell</h3><p>关于bash的编程环境，首先我们要先理解的就是bash的参数。不同方式启动的bash一般默认的参数是不一样的。一般在命令行中使用的bash，都是以login方式打开的，对应的参数是：-l或—login。还有-i参数，表示bash是以交互方式打开的，在默认情况下，不加任何参数的bash也是交互方式打开的。这两种方式都会在启动bash之前加载一些文件：</p>
<p>首先，bash去检查/etc/profile文件是否存在，如果存在就读取并执行这个文件中的命令。</p>
<p>之后，bash再按照以下列出的文件顺序依次查看是否存在这些文件，如果任何一个文件存在，就读取、执行文件中的命令：</p>
<ol>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
</ol>
<p>这里要注意的是，本步骤只会检查到一个文件并处理，即使同时存在2个或3个文件，本步骤也只会处理最优先的那个文件，而忽略其他文件。以上两个步骤的检查都可以用—noprofile参数进行关闭。</p>
<p>当bash是以login方式登录的时候，在bash退出时（exit），会额外读取并执行~/.bash_logout文件中的命令。</p>
<p>当bash是以交互方式登录时（-i参数），bash会读取并执行~/.bashrc中的命令。—norc参数可以关闭这个功能，另外还可以通过—rcfile参数指定一个文件替代默认的~/.bashrc文件。</p>
<p>以上就是bash以login方式和交互式方式登录的主要区别，根据这个过程，我们到RHEL7的环境上看看都需要加载哪些配置：</p>
<p>1.首先是加载/etc/profile。根据RHEL7上此文件内容，这个脚本还需要去检查/etc/profile.d/目录，将里面以.sh结尾的文件都加载一遍。具体细节可以自行查看本文件内容。<br>2.之后是检查~/.bash_profile。这个文件中会加载~/.bashrc文件。<br>3.之后是处理~/.bashrc文件。此文件主要功能是给bash环境添加一些alias，之后再加载/etc/bashrc文件。<br>4.最后处理/etc/bashrc文件。这个过程并不是bash自身带的过程，而是在RHEL7系统中通过脚本调用实现。</p>
<p>了解了这些之后，如果你的bash环境不是在RHEL7系统上，也应该可以确定在自己环境中启动的bash到底加载了哪些配置文件。</p>
<h3 id="bash和sh"><a href="#bash和sh" class="headerlink" title="bash和sh"></a>bash和sh</h3><p>几乎所有人都知道bash有个别名叫sh，也就是说在一个脚本前面写!#/bin/bash和#!/bin/sh似乎没什么不同。但是下面我们要看看它们究竟有什么不同。</p>
<p>首先，第一个区别就是这两个文件并不是同样的类型。如果细心观察过这两个文件的话，大家会发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls -l /usr/bin/sh</div><div class="line">lrwxrwxrwx 1 root root 4 11月 24 04:20 /usr/bin/sh -&gt; bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls -l /usr/bin/bash</div><div class="line">-rwxr-xr-x 1 root root 791304 11月 24 04:20 /usr/bin/bash</div></pre></td></tr></table></figure>
<p>sh是指向bash的一个符号链接。符号链接就像是快捷方式，那么执行sh就是在执行bash。这说明什么？说明这两个执行方式是等同的么？实际上并不是。我们都知道在程序中是可以获得自己执行命令的进程名称的，这个方法在bash编程中可以使用$0变量来实现，参见如下脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat name.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo $0</div><div class="line"></div><div class="line">case $0 in</div><div class="line">*name.sh)</div><div class="line">echo &quot;My name is name!&quot;</div><div class="line">;;</div><div class="line">*na.sh)</div><div class="line">echo &quot;My name is na&quot; </div><div class="line">;;</div><div class="line">*)</div><div class="line">echo &quot;Name error!&quot;</div><div class="line">;;</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>这个脚本直接执行的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./name.sh </div><div class="line">./name.sh</div><div class="line">My name is name!</div></pre></td></tr></table></figure>
<p>大家也能看到脚本中有个逻辑是，如果进程名字是以na.sh结尾，那么打印的内容不一样。我们如何能让同一个程序触发这段不同的逻辑呢？其实很简单，就是给这个脚本创建一个叫na.sh的符号链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ln -s name.sh na.sh </div><div class="line">[zorro@zorrozou-pc0 bash]$ ./na.sh </div><div class="line">./na.sh</div><div class="line">My name is na</div></pre></td></tr></table></figure>
<p>通过符号链接的方式改变进程名称是一种常见的编程技巧，我们可以利用这个办法让程序通过不同进程名触发不同处理逻辑。所以大家以后再遇到类似bash和sh这样的符号链接关系的进程时要格外注意它们的区别。在这里它们到底有什么区别呢？实际上bash的源代码中对以bash名称和sh名称执行的时候，会分别触发不同的逻辑，主要的逻辑区别是：以sh名称运行时，会相当于以—posix参数方式启动bash。这个方式跟一般方式的具体区别可以参见：<a href="http://tiswww.case.edu/php/chet/bash/POSIX。" target="_blank" rel="external">http://tiswww.case.edu/php/chet/bash/POSIX。</a></p>
<p>我遇到过很多次因为不同文件名的处理逻辑不同而引发的问题。其中一次是因为posix模式和一般模式的ulimit -c设置不同导致的。ulimit -c参数可以设置进程出现coredump时产生的文件的大小限制。因为内存的页大多都是4k，所以一般core文件都是最小4k一个，当ulimit -c参数设置小于4k时，无法正常产生core文件。为了调试方便，我们的生产系统都开了ulimit -c限制单位为4。因为默认ulimit -c的限制单位是1k，ulimit -c 4就是4k，够用了。但是我们仍然发现部分服务器不能正常产生core文件，最后排查定位到，这些不能产生core文件的配置脚本只要将#!/bin/sh改为#!/bin/bash就可以正常产生core文件。于是郁闷之余，查阅了bash的处理代码，最终发现原来是这个坑导致的问题。原因是：在posix模式下，ulimit -c的参数单位不是1024，而是512。至于还有什么其他不同，在上述链接中都有说明。</p>
<h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><p>程序员对程序的调试工作是必不可少的，bash本身对脚本程序提供的调试手段不多，printf大法是必要技能之一，当然在bash中就是echo大法。另外就是bash的-v参数、-x参数和-n参数。</p>
<p>-v参数就是可视模式，它会在执行bash程序的时候将要执行的内容也打印出来，除此之外，并不改变bash执行的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat arg.sh</div><div class="line">#!/bin/bash -v</div><div class="line"></div><div class="line">echo $0</div><div class="line">echo $1</div><div class="line">echo $2</div><div class="line">ls /123</div><div class="line">echo $3</div><div class="line">echo $4</div><div class="line"></div><div class="line">echo $#</div><div class="line">echo $*</div><div class="line">echo $?</div></pre></td></tr></table></figure>
<p>执行结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./arg.sh 111 222 333 444 555</div><div class="line">#!/bin/bash -v</div><div class="line"></div><div class="line">echo $0</div><div class="line">./arg.sh</div><div class="line">echo $1</div><div class="line">111</div><div class="line">echo $2</div><div class="line">222</div><div class="line">ls /123</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">echo $3</div><div class="line">333</div><div class="line">echo $4</div><div class="line">444</div><div class="line"></div><div class="line">echo $#</div><div class="line">5</div><div class="line">echo $*</div><div class="line">111 222 333 444 555</div><div class="line">echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>-n参数用来检查bash的语法错误，并且不会真正执行bash脚本。这个就不举例子了。另外，三种方式除了可以直接在bash后面加参数以外，还可以在程序中随时使用内建命令set打开和关闭，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat arg.sh</div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">set -v</div><div class="line">#set -o verbose</div><div class="line">echo $0</div><div class="line">set +v</div><div class="line">echo $1</div><div class="line">set -x</div><div class="line">#set -o xtrace</div><div class="line">echo $2</div><div class="line">ls /123</div><div class="line">echo $3</div><div class="line">set +x</div><div class="line">echo $4</div><div class="line"></div><div class="line">echo $#</div><div class="line"></div><div class="line">set -n</div><div class="line">#set -o noexec</div><div class="line">echo $*</div><div class="line">echo $?</div><div class="line">set +n</div></pre></td></tr></table></figure>
<p>执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./arg.sh </div><div class="line">#set -o verbose</div><div class="line">echo $0</div><div class="line">./arg.sh</div><div class="line">set +v</div><div class="line"></div><div class="line">+ echo</div><div class="line"></div><div class="line">+ ls /123</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">+ echo</div><div class="line"></div><div class="line">+ set +x</div><div class="line"></div><div class="line">0</div></pre></td></tr></table></figure>
<p>以上例子中顺便演示了1、3、#、?的意义，大家可以自行对比它们的区别以理解参数的意义。另外再补充一个-e参数，这个参数可以让bash脚本命令执行错误的时候直接退出，而不是继续执行。这个功能在某些调试的场景下非常有用！</p>
<p>本节只列出了几个常用的参数的意义和使用注意事项，希望可以起到抛砖引玉的作用。大家如果想要学习更多的bash参数，可以自行查看bash的man手册，并详细学习set和shopt命令的使用方法。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>我们目前已经知道有个PATH变量，bash会在查找外部命令的时候到PATH所记录的目录中进行查找，从这个例子我们可以先理解一下环境变量的作用。环境变量就类似PATH这种变量，是bash预设好的一些可能会对其状态和行为产生影响的变量。bash中实现的环境变量个数大概几十个，所有的帮助说明都可以在man bash中找到。我们还是拿一些会在bash编程中经常用到的来讲解一下。</p>
<p>我们可以使用env命令来查看当前bash已经定义的环境变量。set命令不加任何参数可以查看当前bash环境中的所有变量，包括环境变量和私有的一般变量。一般变量的定义方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ aaa=1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep aaa</div><div class="line">[zorro@zorrozou-pc0 ~]$ set|grep aaa</div><div class="line">aaa=1000</div></pre></td></tr></table></figure>
<p>上面我们定义了一个变量名字叫做aaa，我们能看到在set命令中可以显示出这个变量，但是env不显示。export命令可以将一个一般变量编程环境变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ export aaa</div><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep aaa</div><div class="line">aaa=1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ set|grep aaa</div><div class="line">aaa=1000</div></pre></td></tr></table></figure>
<p>export之后，env和set都能看到这个变量了。一般变量和环境变量的区别是：一般变量不能被子进程继承，而环境变量会被子进程继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep aaa</div><div class="line">aaa=1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ bbb=2000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $bbb</div><div class="line">2000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ env|grep bbb</div><div class="line">[zorro@zorrozou-pc0 ~]$ bash</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $aaa</div><div class="line">1000</div><div class="line">[zorro@zorrozou-pc0 ~]$ echo $bbb</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 ~]$</div></pre></td></tr></table></figure>
<p>上面测试中，我们的bash环境里有一个环境变量aaa＝1000，又定义了一个一般变量bbb＝2000。此时我们在用bash打开一个子进程，在子进程中我们发现，aaa变量仍然能取到值，但是bbb不可以。证明aaa可以被子进程继承，bbb不可以。</p>
<p>搞清楚了环境变量的基础知识之后，再来看一下bash中常用的环境变量：</p>
<p>进程自身信息相关</p>
<p>BASH：当前bash进程的进程名。</p>
<p>BASHOPTS：记录了shopt命令已经设置为打开的选项。</p>
<p>BASH_VERSINFO：bash的版本号信息，是一个数组。可以使用命令：echo ${BASH_VERSINFO[*]}查看数组的信息。有关数组的操作我们会在其它文章里详细说明。</p>
<p>BASH_VERSION：bash的版本号信息。比上一个信息更少一点。</p>
<p>HOSTNAME：系统主机名信息。</p>
<p>HOSTTYPE：系统类型信息。</p>
<p>OLDPWD：上一个当前工作目录。</p>
<p>PWD：当前工作目录。</p>
<p>HOME：主目录。一般指进程uid对应用户的主目录。</p>
<p>SHELL：bash程序所在路径。</p>
<p>常用数字</p>
<p>RANDOM：每次取这个变量的值都能得到一个0-32767的随机数。</p>
<p>SECONDS：当前bash已经开启了多少秒。</p>
<p>BASHPID：当前bash进程的PID。</p>
<p>EUID：进程的有效用户id。</p>
<p>GROUPS：进程组身份。</p>
<p>PPID：父进程PID。</p>
<p>UID：用户uid。</p>
<p>提示符</p>
<p>PS1：用户bash的交互提示符，主提示符。</p>
<p>PS2：第二提示符，主要用在一些除了PS1之外常见的提示符场景，比如输入了’之后回车，就能看到这个提示符。</p>
<p>PS3：用于select语句的交互提示符。</p>
<p>PS4：用于跟踪执行过程时的提示符，一般显示为”+”。比如我们在bash中使用set -x之后的跟踪提示就是这个提示符显示的。</p>
<h2 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h2><p>交互bash中提供一种方便追溯曾经使用的命令的功能，叫做命令历史功能。就是将曾经用过的命令纪录下来，以备以后查询或者重复调用。这个功能在交互方式的bash中默认打开，在bash编程环境中默认是没有开启的。可以使用set +H来关闭这个功能，set -H打开这个功能。在开启了history功能的bash中我们可以使用history内建命令查询当前的命令历史列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ history </div><div class="line">1 sudo bash</div><div class="line">2 ps ax</div><div class="line">3 ls</div><div class="line">4 ip ad sh</div></pre></td></tr></table></figure>
<p>命令历史的相关配置都是通过bash的环境变量来完成的：</p>
<p>HISTFILE：记录命令历史的文件路径。</p>
<p>HISTFILESIZE：命令历史文件的行数限制</p>
<p>HISTCONTROL：这个变量可以用来控制命令历史的一些特性。比如一般的命令历史会完全按照我们执行命令的顺序来完整记录，如果我们连续执行相同的命令，也会重复记录，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ history </div><div class="line">......</div><div class="line">1173 pwd</div><div class="line">1174 pwd</div><div class="line">1175 pwd</div><div class="line">1176 history</div></pre></td></tr></table></figure>
<p>我们可以利用这个变量的配置来消除命令历史中的重复记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ export HISTCONTROL=ignoredups</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ pwd</div><div class="line">/home/zorro/bash</div><div class="line">[zorro@zorrozou-pc0 bash]$ history </div><div class="line">1177 export HISTCONTROL=ignoredups</div><div class="line">1178 history </div><div class="line">1179 pwd</div><div class="line">1180 history</div></pre></td></tr></table></figure>
<p>这个变量还有其它配置，ignorespace可以用来让history忽略以空格开头的命令，ignoreboth可以同时起到ignoredups和ignorespace的作用，</p>
<p>HISTIGNORE：可以控制history机制忽略某些命令，配置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HISTIGNORE=”pwd:ls:cd:”。</div></pre></td></tr></table></figure>
<p>HISTSIZE：命令历史纪录的命令个数。</p>
<p>HISTTIMEFORMAT：可以用来定义命令历史纪录的时间格式.在命令历史中记录命令执行时间有时候很有用，配置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export HISTTIMEFORMAT=&apos;%F %T &apos;</div></pre></td></tr></table></figure>
<p>相关时间格式的帮助可以查看man 3 strftime。</p>
<p>HISTCMD：当前命令历史的行数。</p>
<p>在交互式操作bash的时候，可以通过一些特殊符号对命令历史进行快速调用，这些符号基本都是以!开头的，除非!后面跟的是空格、换行、等号=或者小括号()：</p>
<p>!n：表示引用命令历史中的第n条命令，如：!123，执行第123条命令。</p>
<p>!-n：表示引用命令历史中的倒数第n条命令，如：!-123，执行倒数第123条命令。</p>
<p>!!：重复执行上一条命令。</p>
<p>!string：在命令历史中找到最近的一条以string字符串开头的命令并执行。</p>
<p>!?string[?]：在命令历史中找到最近的一条包括string字符的命令并执行。如果最有一个?省略的话，就是找到以string结尾的命令。</p>
<p>^string1^string2^：将上一个命令中的string1字符串替换成string2字符串并执行。可以简写为：^string1^string2</p>
<p>!#：重复当前输入的命令。</p>
<p>以下符号可以作为某个命令的单词代号，如：</p>
<p>^：!^表示上一条命令中的第一个参数，$123^表示第123条命令的第一个参数。</p>
<p>$：!$表示上一条命令中的最后一个参数。!123$表示第123条命令的最后一个参数。</p>
<p>n（数字）：!!0表示上一条命令的命令名，!!3上一条命令的第三个参数。!123:3第123条命令的第三个参数。</p>
<p>：表示所有参数，如：!123:\或!123*</p>
<p>x-y：x和y都是数字，表示从第x到第y个参数，如：!123:1-6表示第123条命令的第1个到第6个参数。只写成-y，取前y个，如：!123:-7表示0-7。</p>
<p>x：表示取从第x个参数之后的所有参数，相当于x-$。如：!123:2\</p>
<p>x-：表示取从第x个参数之后的所有参数，不包括最后一个。如：!123:2-</p>
<p>选择出相关命令或者参数之后，我们还可以通过一些命令对其进行操作：</p>
<p>h 删除所有后面的路径，只留下前面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/passwd</div><div class="line">/etc/passwd</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:h</div><div class="line">ls /etc</div><div class="line">...</div></pre></td></tr></table></figure>
<p>紧接着上面的命令执行，相当于运行passwd。</p>
<p>r 删除后缀.xxx, 留下文件名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls 123.txt</div><div class="line">ls: cannot access &apos;123.txt&apos;: No such file or directory</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:r</div><div class="line">ls 123</div></pre></td></tr></table></figure>
<p>e 删除文件名, 留下后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ !-2:e</div><div class="line">.txt</div><div class="line">bash: .txt: command not found</div></pre></td></tr></table></figure>
<p>p 只打印结果命令，但不执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/passwd</div><div class="line">/etc/passwd</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:p</div><div class="line">ls /etc/passwd</div></pre></td></tr></table></figure>
<p>q 防止代换参数被再次替换，相当于给选择的参数加上了’’，以防止其被转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls `echo /etc/passwd`</div><div class="line">/etc/passwd</div><div class="line">[zorro@zorrozou-pc0 bash]$ !!:q</div><div class="line">&apos;ls `echo /etc/passwd`&apos;</div><div class="line">-bash: ls `echo /etc/passwd`: No such file or directory</div></pre></td></tr></table></figure>
<p>x 作用同上，区别是每个参数都会分别给加上’’。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ !-2:x</div><div class="line">&apos;ls&apos; &apos;`echo&apos; &apos;/etc/passwd`&apos;</div><div class="line">ls: cannot access &apos;`echo&apos;: No such file or directory</div><div class="line">ls: cannot access &apos;/etc/passwd`&apos;: No such file or directory</div></pre></td></tr></table></figure>
<p>s/old/new/ 字符串替换，跟上面的^^类似，但是可以指定任意历史命令。只替换找到的第一个old字符串。<br>&amp; 重复上次替换<br>g 在执行s或者＆命令作为前缀使用，表示全局替换。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>每一个进程环境中都有对于资源的限制，bash脚本也不例外。我们可以使用ulimit内建命令查看和设置bash环境中的资源限制。</p>
<p>[zorro@zorrozou-pc0 ~]$ ulimit -a<br>core file size (blocks, -c) unlimited<br>data seg size (kbytes, -d) unlimited<br>scheduling priority (-e) 0<br>file size (blocks, -f) unlimited<br>pending signals (-i) 63877<br>max locked memory (kbytes, -l) 64<br>max memory size (kbytes, -m) unlimited<br>open files (-n) 1024<br>pipe size (512 bytes, -p) 8<br>POSIX message queues (bytes, -q) 819200<br>real-time priority (-r) 0<br>stack size (kbytes, -s) 8192<br>cpu time (seconds, -t) unlimited<br>max user processes (-u) 63877<br>virtual memory (kbytes, -v) unlimited<br>file locks (-x) unlimited</p>
<p>在上文讲述bash和sh之间的区别时，我们已经接触过这个命令中的-c参数了，用来限制core文件的大小。我们再来看看其它参数的含义：</p>
<p>data seg size：程序的数据段限制。</p>
<p>scheduling priority：优先级限制。相关概念的理解可以参考这篇：<a href="http://wp.me/p79Cit-S" target="_blank" rel="external">http://wp.me/p79Cit-S</a></p>
<p>file size：文件大小限制。</p>
<p>pending signals：未决信号个数限制。</p>
<p>max locked memory：最大可以锁内存的空间限制。</p>
<p>max memory size：最大物理内存使用限制。</p>
<p>open files：文件打开个数限制。</p>
<p>pipe size：管道空间限制。</p>
<p>POSIX message queues：POSIX消息队列空间限制。</p>
<p>real-time priority：实时优先级限制。相关概念的理解可以参考这篇：<a href="http://wp.me/p79Cit-S" target="_blank" rel="external">http://wp.me/p79Cit-S</a></p>
<p>stack size：程序栈空间限制。</p>
<p>cpu time：占用CPU时间限制。</p>
<p>max user processes：可以打开的的进程个数限制。</p>
<p>virtual memory：虚拟内存空间限制。</p>
<p>file locks：锁文件个数限制。</p>
<p>以上参数涉及各方面的相关知识，我们在此就不详细描述这些相关内容了。在此我们主要关注open files和max user processes参数，这两个参数是我们在优化系统时最常用的两个参数。</p>
<p>这里需要注意的是，使用ulimit命令配置完这些参数之后的bash产生的子进程都会继承父进程的相关资源配置。ulimit的资源配置的继承关系类似环境变量，父进程的配置变化可以影响子进程。所以，如果我们只是在某个登录shell或者交互式shell中修改了ulimit配置，那么在这个bash环境中执行的命令和产生的子进程都会受到影响，但是对整个系统的其它进程没有影响。如果我们想要让所有用户一登录就有相关的配置，可以考虑把ulimit命令写在bash启动的相关脚本中，如/etc/profile。如果只想影响某一个用户，可以写在这个用户的主目录的bash启动脚本中，如~/.bash_profile。系统的pam模块也给我们提供了配置ulimit相关限制的配置方法，在centos7中大家可以在以下目录和文件中找到相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/security/limits.d/</div><div class="line">10-gcr.conf 99-audio.conf</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls /etc/security/limits.conf </div><div class="line">/etc/security/limits.conf</div></pre></td></tr></table></figure>
<p>即使是写在pam相关配置文件中的相关配置，也可能不是系统全局的。如果你想给某一个后台进程设置ulimit，最靠谱的办法还是在它的启动脚本中进行配置。无论如何，只要记得一点，如果相关进程的ulimit没生效，要想的是它的父进程是谁？它的父进程是不是生效了？</p>
<p>ulimit参数中绝大多数配置都是root才有权限改的更大，而非root身份只能在现有的配置基础上减小限制。如果你执行ulimit的时候报错了，请注意是不是这个原因。<br>```</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>通过本文我们学习了bash编程的进程环境的相关内容，主要包括的知识点为：</p>
<ul>
<li>bash的常用参数。</li>
<li>bash的环境变量。</li>
<li>命令历史功能和相关变量配置。</li>
<li>bash脚本的资源限制ulimit的使用。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/24/shell-1/" title="SHELL编程之执行过程" itemprop="url">SHELL编程之执行过程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-24T01:35:00.000Z" itemprop="datePublished"> Published 2016-05-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="SHELL编程之执行过程"><a href="#SHELL编程之执行过程" class="headerlink" title="SHELL编程之执行过程"></a>SHELL编程之执行过程</h1><p>每次看这位大大的文章都会收获很多<br>文章转自<a href="http://liwei.life/2016/05/23/shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="external">SHELL编程之执行过程</a><br>作者相关:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">微博ID：**orroz**</div><div class="line"></div><div class="line">微信公众号：**Linux系统技术**</div></pre></td></tr></table></figure></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是shell编程系列的第二篇，主要介绍bash脚本是如何执行命令的。通过本文，您应该可以解决以下问题：</p>
<ul>
<li><p>脚本开始的#!到底是怎么起作用的？</p>
</li>
<li><p>bash执行过程中的字符串判断顺序究竟是什么样？</p>
</li>
<li><p>如果我们定义了一个函数叫ls，那么调用ls的时候，到底bash是执行ls函数还是ls命令？</p>
</li>
<li><p>内建命令和外建命令到底有什么差别？</p>
</li>
<li><p>程度退出的时候要注意什么？</p>
</li>
</ul>
<h1 id="以魔法-开始"><a href="#以魔法-开始" class="headerlink" title="以魔法#!开始"></a>以魔法#!开始</h1><p>一个脚本程序的开始方式都比较统一，它们几乎都开始于一个#!符号。这个符号的作用大家似乎也都知道，叫做声明解释器。脚本语言跟编译型语言的不一样之处主要是脚本语言需要解释器。因为脚本语言主要是文本，而系统中能够执行的文件实际上都是可执行的二进制文件，就是编译好的文件。文本的好处是人看方便，但是操作系统并不能直接执行，所以就需要将文本内容传递给一个可执行的二进制文件进行解析，再由这个可执行的二进制文件根据脚本的内容所确定的行为进行执行。可以做这种解析执行的二进制可执行程序都可以叫做解释器。</p>
<p>脚本开头的#!就是用来声明本文件的文本内容是交给那个解释器进行解释的。比如我们写bash脚本，一般声明的方法是#!/bin/bash或#!/bin/sh。如果写的是一个python脚本，就用#!/usr/bin/python。当然，在不同环境的系统中，这个解释器放的路径可能不一样，所以固定写一个路径的方式就可能造成脚本在不同环境的系统中不通用的情况，于是就出现了这样的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env 脚本解释器名称</div></pre></td></tr></table></figure>
<p>这就利用了env命令可以得到可执行程序执行路径的功能，让脚本自行找到在当前系统上到底解释器在什么路径。让脚本更具通用性。但是大家有没有想过一个问题，大多数脚本语言都是将#后面出现的字符当作是注释，在脚本中并不起作用。这个#!和这个注释的规则不冲突么？</p>
<p>这就要从#!符号起作用的原因说起，其实也很简单，这个功能是由操作系统的程序载入器做的。在Linux操作系统上，出了1号进程以外，我们可以认为其它所有进程都是由父进程fork出来的。所以对bash来说，所谓的载入一个脚本执行，无非就是父进程调用fork()、exec()来产生一个子进程。这#!就是在内核处理exec的时候进行解析的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">内核中整个调用过程如下（linux 4.4），内核处理exec族函数的主要实现在fs/exec.c文件的do_execveat_common()方法中，其中调用exec_binprm()方法处理执行逻辑，这函数中使用</div><div class="line">search_binary_handler()对要加载的文件进行各种格式的判断，脚本（script）只是其中的一种。确定是script格式后，就会调用script格式对应的load_binary方法：</div><div class="line">load_script()进行处理，#!就是在这个函数中解析的。解析到了#!以后，内核会取其后面的可执行程序路径，再传递给search_binary_handler（）重新解析。</div><div class="line">这样最终找到真正的可执行二进制文件进行相关执行操作。</div></pre></td></tr></table></figure>
<p>因此，对脚本第一行的#!解析，其实是内核给我们变的魔术。#!后面的路径内容在起作用的时候还没有交给脚本解释器。很多人认为#!这一行是脚本解释器去解析的，然而并不是。了解了原理之后，也顺便明白了为什么#!一定要写在第一行的前两个字符，因为这是在内核里写死的，它就只检查前两个字符。当内核帮你选好了脚本解释器之后，后续的工作就都交给解释器做了。脚本的所有内容也都会原封不动的交给解释器再次解释，是的，包括#!。但是由于对于解释器来说，#开头的字符串都是注释，并不生效，所以解释器自然对#!后面所有的内容无感，继续解释对于它来说有意义的字符串去了。</p>
<p>我们可以用一个自显示脚本来观察一下这个事情，什么是自显示脚本？无非就是#!/bin/cat，这样文本的所有内容包括#!行都会交给cat进行显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat cat.sh </div><div class="line">#!/bin/cat</div><div class="line"></div><div class="line">echo &quot;hello world!&quot;</div><div class="line">[zorro@zorrozou-pc0 bash]$ ./cat.sh </div><div class="line">#!/bin/cat</div><div class="line"></div><div class="line">echo &quot;hello world!&quot;</div></pre></td></tr></table></figure>
<p>或者自删除脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat rm.sh </div><div class="line">#!/bin/rm</div><div class="line"></div><div class="line">echo &quot;hello world!&quot;</div><div class="line">[zorro@zorrozou-pc0 bash]$ chmod +x rm.sh </div><div class="line">[zorro@zorrozou-pc0 bash]$ ./rm.sh </div><div class="line">[zorro@zorrozou-pc0 bash]$ cat rm.sh</div><div class="line">cat: rm.sh: No such file or directory</div></pre></td></tr></table></figure>
<p>这就是#!的本质。</p>
<h2 id="bash如何执行shell命令？"><a href="#bash如何执行shell命令？" class="headerlink" title="bash如何执行shell命令？"></a>bash如何执行shell命令？</h2><p>刚才我们从#!的作用原理讲解了一个bash脚本是如何被加载的。就是说当#!/bin/bash的时候，实际上内核给我们启动了一个bash进程，然后把脚本内容都传递给bash进行解析执行。实际上，无论在脚本里还是在命令行中，bash对文本的解析方法大致都是一样的。首先，bash会以一些特殊字符作为分隔符，将文本进行分段解析。最主要的分隔符无疑就是回车，类似功能的分隔符还有分号”;”。所以在bash脚本中是以回车或者分号作为一行命令结束的标志的。这基本上就是第一层级的解析，主要目的是将大段的命令行进行分段。</p>
<p>之后是第二层级解析，这一层级主要是区分所要执行的命令。这一层级主要解析的字符是管道”|”，&amp;&amp;、||这样的可以起到连接命令作用的特殊字符。这一层级解析完后，bash就能拿到最基本的一个个的要执行的命令了。</p>
<p>当然拿到命令之后还要继续第三层解析，这一层主要是区分出要执行的命令和其参数，主要解析的是空格和tab字符。这一层次解析完之后，bash才开始对最基本的字符串进行解释工作。当然，绝大多数解析完的字符串，bash都是在fork之后将其传递给exec进行执行，然后wait其执行完毕之后再解析下一行。这就是bash脚本也被叫做批处理脚本的原因，主要执行过程是一个一个指令串行执行的，上一个执行完才执行下一个。以上这个过程并不能涵盖bash解释字符串的全过程，实际情况要比这复杂。</p>
<p>bash在解释命令的时候为了方便一些操作和提高某些效率做了不少特性，包括alias功能和外部命令路径的hash功能。bash还因为某些功能不能做成外部命令，所以必须实现一些内建命令，比如cd、pwd等命令。当然除了内建命令以外，bash还要实现一些关键字，比如其编程语法结构的if或是while这样的功能。实际上作为一种编程语言，bash还要实现函数功能，我们可以理解为，bash的函数就是将一堆命令做成一个命令，然后调用执行这个名字，bash就是去执行事先封装好的那堆命令。</p>
<p>好吧，问题来了：我们已知有一个内建命令叫做cd，如果此时我们又建立一个alias也叫cd，那么当我在bash中敲入cd并回车之后，bash究竟是将它当成内建命令解释还是当成alias解释？同样，如果cd又是一个外部命令能？如果又是一个hash索引呢？如果又是一个关键字或函数呢？</p>
<p>实际上bash在做这些功能的时候已经安排好了它们在名字冲突的情况下究竟该先以什么方式解释。优先顺序是：</p>
<ol>
<li><p>别名：alias</p>
</li>
<li><p>关键字：keyword</p>
</li>
<li><p>函数：function</p>
</li>
<li><p>内建命令：built in</p>
</li>
<li><p>哈西索引：hash</p>
</li>
<li><p>外部命令：command</p>
</li>
</ol>
<p>这些bash要判断的字符串类型都可以用type命令进行判断，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ type egrep</div><div class="line">egrep is aliased to &apos;egrep --color=auto&apos;</div><div class="line">[zorro@zorrozou-pc0 bash]$ type if</div><div class="line">if is a shell keyword</div><div class="line">[zorro@zorrozou-pc0 bash]$ type pwd</div><div class="line">pwd is a shell builtin</div><div class="line">[zorro@zorrozou-pc0 bash]$ type passwd</div><div class="line">passwd is /usr/bin/passwd</div></pre></td></tr></table></figure>
<h3 id="别名alias"><a href="#别名alias" class="headerlink" title="别名alias"></a>别名alias</h3><p>bash提供了一种别名(alias)功能，可以将某一个字符串做成另一个字符串的别名，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ alias cat=&apos;cat -n&apos;</div><div class="line">[zorro@zorrozou-pc0 bash]$ cat /etc/passwd</div><div class="line">     1  root:x:0:0:root:/root:/bin/bash</div><div class="line">     2  bin:x:1:1:bin:/bin:/usr/bin/nologin</div><div class="line">     3  daemon:x:2:2:daemon:/:/usr/bin/nologin</div><div class="line">     4  mail:x:8:12:mail:/var/spool/mail:/usr/bin/nologin</div><div class="line">     ......</div></pre></td></tr></table></figure>
<p>于是我们再使用cat命令的时候，bash会将其解释为cat -n。</p>
<p>这个功能在交互方式进行bash操作的时候可以提高不少效率。如果我们发现我们常用到某命令的某个参数的时候，就可以将其做成alias，以后就可以方便使用了。交互bash中，我们可以用alias命令查看目前已经有的alias列表。可以用unalias取消这个别名设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ alias </div><div class="line">alias cat=&apos;cat -n&apos;</div><div class="line"></div><div class="line">[zorro@zorrozou-pc0 bash]$ unalias cat</div></pre></td></tr></table></figure>
<p>alias功能在交互打开的bash中是默认开启的，但是在bash脚本中是默认关闭的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#shopt -s expand_aliases</div><div class="line"></div><div class="line">alias ls=&apos;ls -l&apos;</div><div class="line">ls /etc</div></pre></td></tr></table></figure>
<p>此时本程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./alias.sh </div><div class="line">adjtime       cgconfig.conf         docker       group      ifplugd     libao.conf      mail.rc      netconfig       passwd   request-key.conf  shells         udisks2</div><div class="line">adobe         cgrules.conf          drirc   ...</div></pre></td></tr></table></figure>
<p>使用注释行中的shopt -s expand_aliases命令可以打开alias功能支持，我们将这行注释取消掉之后的执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./alias.sh </div><div class="line">total 1544</div><div class="line">-rw-r--r-- 1 root    root        44 11月 13 19:53 adjtime</div><div class="line">drwxr-xr-x 2 root    root      4096 4月  20 09:34 adobe</div><div class="line">-rw-r--r-- 1 root    root       389 4月  18 22:19 appstream.conf</div><div class="line">-rw-r--r-- 1 root    root         0 10月  1 2015 arch-release</div><div class="line">-rw-r--r-- 1 root    root       260 7月   1 2014 asound.conf</div><div class="line">drwxr-xr-x 3 root    root      4096 3月  11 10:09 avahi</div></pre></td></tr></table></figure>
<p>这就是bash的alias功能。</p>
<h3 id="关键字：keyword"><a href="#关键字：keyword" class="headerlink" title="关键字：keyword"></a>关键字：keyword</h3><p>关键字的概念很简单，主要就是bash提供的语法。比如if，while，function等等。对这些关键字使用type命令会显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ type function</div><div class="line">function is a shell keyword</div></pre></td></tr></table></figure>
<p>说明这是一个keyword。我想这个概念没什么可以解释的了，无非就是bash提供的一种语法而已。只是要注意，bash会在判断alias之后才来判断字符串是不是个keyword。就是说，我们还是可以创建一个叫if的alias，并且在执行的时候，bash只把它当成alias看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ alias if=&apos;echo zorro&apos;</div><div class="line">[zorro@zorrozou-pc0 bash]$ if</div><div class="line">zorro</div><div class="line">[zorro@zorrozou-pc0 bash]$ unalias if</div></pre></td></tr></table></figure>
<h3 id="函数：function"><a href="#函数：function" class="headerlink" title="函数：function"></a>函数：function</h3><p>bash在判断完字符串不是一个关键字之后，将会检查其是不是一个函数。在bash编程中，我们可以使用关键字function来定义一个函数，当然这个关键字其实也可以省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">name () compound-command [redirection]</div><div class="line">function name [()] compound-command [redirection]</div></pre></td></tr></table></figure>
<p>语法结构中的compound-command一般是放在{}里的一个命令列表（list）。定义好的函数其实就是一系列shell命令的封装，并且它还具有很多bash程序的特征，比如在函数内部可以使用$1，$2等这样的变量来判断函数的参数，也可以对函数使用重定向功能。</p>
<p>关于函数的更细节讨论我们会在后续的文章中展开说明，再这里我们只需要知道它对于bash来说是第几个被解释的即可。</p>
<h3 id="内建命令：built-in"><a href="#内建命令：built-in" class="headerlink" title="内建命令：built in"></a>内建命令：built in</h3><p>在判断完函数之后，bash将查看给的字符串是不是一个内建命令。内建命令是相对于外建命令来说的。其实我们在bash中执行的命令最常见的是外建（外部）命令。比如常见的ls，find，passwd等。这些外建命令的特点是，它们是作为一个可执行程序放在$PATH变量所包含的目录中的。bash在执行这些命令的时候，都会进行fork(),exec()并且wait()。就是用标准的打开子进程的方式处理外部命令。但是内建命令不同，这些命令都是bash自身实现的命令，它们不依靠外部的可执行文件存在。只要有bash，这些命令就可以执行。典型的内建命令有cd、pwd等。大家可以直接help cd或者任何一个内建命令来查看它们的帮助。大家还可以man bash来查看bash相关的帮助，当然也包括所有的内建命令。</p>
<p>其实内建命令的个数并不会很多，一共大概就这些：</p>
<p>:,  ., [, alias, bg, bind, break, builtin, caller, cd, command, compgen, complete, compopt, continue, declare, dirs, disown, echo, enable, eval, exec, exit, export, false, fc,<br>   fg, getopts, hash, help, history, jobs, kill, let, local, logout, mapfile, popd, printf, pushd, pwd, read, readonly, return, set, shift, shopt, source, suspend,  test,  times,  trap,<br>   true, type, typeset, ulimit, umask, unalias, unset, wait</p>
<p>我们在后续的文章中会展开讲解这些命令的功能。</p>
<h3 id="哈西索引：hash"><a href="#哈西索引：hash" class="headerlink" title="哈西索引：hash"></a>哈西索引：hash</h3><p>hash功能实际上是针对外部命令做的一个功能。刚才我们已经知道了，外部命令都是放在$PATH变量对应的路径中的可执行文件。bash在执行一个外部命令时所需要做的操作是：如果发现这个命令是个外部命令就按照$PATH变量中按照目录路径的顺序，在每个目录中都遍历一遍，看看有没有对应的文件名。如果有，就fork、exec、wait。我们系统上一般的$PATH内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ echo $PATH</div><div class="line">/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:</div><div class="line">/usr/bin/vendor_perl:/usr/bin/core_perl:/home/zorro/.local/bin:/home/zorro/bin</div></pre></td></tr></table></figure>
<p>当然，很多系统上的$PATH变量包含的路径可能更多，目录中的文件数量也可能会很多。于是，遍历这些目录去查询文件名的行为就可能比较耗时。于是bash提供了一种功能，就是建立一个bash表，在第一次找到一个命令的路径之后，对其命令名和对应的路径建立一个hash索引。这样下次再执行这个命令的时候，就不用去遍历所有的目录了，只要查询索引就可以更快的找到命令路径，以加快执行程序的速度。</p>
<p>我们可以使用内建命令hash来查看当前已经建立缓存关系的命令和其命中次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ hash</div><div class="line">hits    command</div><div class="line">   1    /usr/bin/flock</div><div class="line">   4    /usr/bin/chmod</div><div class="line">  20    /usr/bin/vim</div><div class="line">   4    /usr/bin/cat</div><div class="line">   1    /usr/bin/cp</div><div class="line">   1    /usr/bin/mkdir</div><div class="line">  16    /usr/bin/man</div><div class="line">  27    /usr/bin/ls</div></pre></td></tr></table></figure>
<p>这个命令也可以对当前的hash表进行操作，-r参数用来清空当前hash表。手工创建一个hash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -p /usr/sbin/passwd psw</div><div class="line">[root@zorrozou-pc0 bash]# psw</div><div class="line">Enter new UNIX password: </div><div class="line">Retype new UNIX password:</div></pre></td></tr></table></figure>
<p>此时我们就可以通过执行psw来执行passwd命令了。查看更详细的hash对应关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -l</div><div class="line">builtin hash -p /usr/bin/netdata netdata</div><div class="line">builtin hash -p /usr/bin/df df</div><div class="line">builtin hash -p /usr/bin/chmod chmod</div><div class="line">builtin hash -p /usr/bin/vim vim</div><div class="line">builtin hash -p /usr/bin/ps ps</div><div class="line">builtin hash -p /usr/bin/man man</div><div class="line">builtin hash -p /usr/bin/pacman pacman</div><div class="line">builtin hash -p /usr/sbin/passwd psw</div><div class="line">builtin hash -p /usr/bin/ls ls</div><div class="line">builtin hash -p /usr/bin/ss ss</div><div class="line">builtin hash -p /usr/bin/ip ip</div></pre></td></tr></table></figure>
<p>删除某一个hash对应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -d psw</div><div class="line">[root@zorrozou-pc0 bash]# hash -l</div><div class="line">builtin hash -p /usr/bin/netdata netdata</div><div class="line">builtin hash -p /usr/bin/df df</div><div class="line">builtin hash -p /usr/bin/chmod chmod</div><div class="line">builtin hash -p /usr/bin/vim vim</div><div class="line">builtin hash -p /usr/bin/ps ps</div><div class="line">builtin hash -p /usr/bin/man man</div><div class="line">builtin hash -p /usr/bin/pacman pacman</div><div class="line">builtin hash -p /usr/bin/ls ls</div><div class="line">builtin hash -p /usr/bin/ss ss</div><div class="line">builtin hash -p /usr/bin/ip ip</div></pre></td></tr></table></figure>
<p>显示某一个hash对应的路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@zorrozou-pc0 bash]# hash -t chmod</div><div class="line">/usr/bin/chmod</div></pre></td></tr></table></figure>
<p>在交互式bash操作和bash编程中，hash功能总是打开的，我们可以用set +h关闭hash功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ cat hash.sh </div><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#set +h</div><div class="line"></div><div class="line">hash</div><div class="line"></div><div class="line">hash -p /usr/bin/useradd uad</div><div class="line"></div><div class="line">hash -t uad</div><div class="line"></div><div class="line">uad</div></pre></td></tr></table></figure>
<p>默认打开hash的脚本输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./hash.sh </div><div class="line">hash: hash table empty</div><div class="line">/usr/bin/useradd</div><div class="line">Usage: uad [options] LOGIN</div><div class="line">       uad -D</div><div class="line">       uad -D [options]</div><div class="line"></div><div class="line">Options:</div><div class="line">  -b, --base-dir BASE_DIR       base directory for the home directory of the</div><div class="line">                            new account</div><div class="line">  -c, --comment COMMENT         GECOS field of the new account</div><div class="line">  -d, --home-dir HOME_DIR       home directory of the new account</div><div class="line">  -D, --defaults                print or change default useradd configuration</div><div class="line">  -e, --expiredate EXPIRE_DATE  expiration date of the new account</div><div class="line">  -f, --inactive INACTIVE       password inactivity period of the new account</div><div class="line">  -g, --gid GROUP               name or ID of the primary group of the new</div><div class="line">                            account</div><div class="line">  -G, --groups GROUPS           list of supplementary groups of the new</div><div class="line">                            account</div><div class="line">  -h, --help                    display this help message and exit</div><div class="line">  -k, --skel SKEL_DIR           use this alternative skeleton directory</div><div class="line">  -K, --key KEY=VALUE           override /etc/login.defs defaults</div><div class="line">  -l, --no-log-init             do not add the user to the lastlog and</div><div class="line">                            faillog databases</div><div class="line">  -m, --create-home             create the user&apos;s home directory</div><div class="line">  -M, --no-create-home          do not create the user&apos;s home directory</div><div class="line">  -N, --no-user-group           do not create a group with the same name as</div><div class="line">                            the user</div><div class="line">  -o, --non-unique              allow to create users with duplicate</div><div class="line">                            (non-unique) UID</div><div class="line">  -p, --password PASSWORD       encrypted password of the new account</div><div class="line">  -r, --system                  create a system account</div><div class="line">  -R, --root CHROOT_DIR         directory to chroot into</div><div class="line">  -s, --shell SHELL             login shell of the new account</div><div class="line">  -u, --uid UID                 user ID of the new account</div><div class="line">  -U, --user-group              create a group with the same name as the user</div></pre></td></tr></table></figure>
<p>关闭hash之后的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ./hash.sh </div><div class="line">./hash.sh: line 5: hash: hashing disabled</div><div class="line">./hash.sh: line 7: hash: hashing disabled</div><div class="line">./hash.sh: line 9: hash: hashing disabled</div><div class="line">./hash.sh: line 11: uad: command not found</div></pre></td></tr></table></figure>
<h3 id="外部命令：command"><a href="#外部命令：command" class="headerlink" title="外部命令：command"></a>外部命令：command</h3><p>除了以上说明之外的命令都会当作外部命令处理。执行外部命令的固定动作就是在$PATH路径下找命令，找到之后fork、exec、wait。如果没有这个可执行文件名，就报告命令不存在。这也是bash最后去判断的字符串类型。</p>
<p>外建命令都是通过fork调用打开子进程执行的，所以bash单纯只用外建命令是不能实现部分功能的。比如大家都知道cd命令是用来修改当前进程的工作目录的，如果这个功能使用外部命令实现，那么进程将fork打开一个子进程，子进程通过chdir()进行当前工作目录的修改时，实际上只改变了子进程本身的当前工作目录，而父进程bash的工作目录没变。之后子进程退出，返回到父进程的交互操作环境之后，用户会发现，当前的bash的pwd还在原来的目录下。所以大家应该可以理解，虽然我们的原则是尽量将所有命令都外部实现，但是还是有一些功能不能以创建子进程的方式达到目的，那么这些功能就必须内部实现。这就是内建命令必须存在的原因。另外要注意：bash在正常调用内部命令的时候并不会像外部命令一样产生一个子进程。</p>
<h2 id="脚本的退出"><a href="#脚本的退出" class="headerlink" title="脚本的退出"></a>脚本的退出</h2><p>一个bash脚本的退出一般有多种方式，比如使用exit退出或者所有脚本命令执行完之后退出。无论怎么样退出，脚本都会有个返回码，而且返回码可能不同。</p>
<p>任何命令执行完之后都有返回码，主要用来判断这个命令是否执行成功。在交互中bash中，我们可以使用$?来查看上一个命令的返回码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ ls /123</div><div class="line">ls: cannot access &apos;/123&apos;: No such file or directory</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $?</div><div class="line">2</div><div class="line">[zorro@zorrozou-pc0 bash]$ ls /</div><div class="line">bin  boot  cgroup  data  dev  etc  home  lib  lib64  lost+found  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $?</div><div class="line">0</div></pre></td></tr></table></figure>
<p>返回码逻辑上有两类，0为真，非零为假。就是说，返回为0表示命令执行成功，非零表示执行失败。返回码的取值范围为0-255。其中错误返回码为1-255。bash为我们提供了一个内建命令exit，通过中这个命令可以人为指定退出的返回码是多少。这个命令的使用是一般进行bash编程的运维人员所不太注意的。我们在上一篇的bash编程语法结构的讲解中说过，if、while语句的条件判断实际上就是判断命令的返回值，如果我们自己写的bash脚本不注意规范的使用脚本退出时的返回码的话，那么这样的bash脚本将可能不可以在别人编写脚本的时候，直接使用if将其作为条件判断，这可能会对程序的兼容性造成影响。因此，请大家注意自己写的bash程序的返回码状态。如果我们的bash程序没有显示的以一个exit指定返回码退出的话，那么其最后执行命令的返回码将成为整个bash脚本退出的返回码。</p>
<p>当然，一个bash程序的退出还可能因为被中间打断而发生，这一般是因为进程接收到了一个需要程序退出的信号。比如我们日常使用的ctrl＋c操作，就是给进程发送了一个2号SIGINT信号。考虑到程序退出可能性的各种可能，系统将错误返回码设计成1-255，这其中还分成两类：</p>
<ul>
<li>程序退出的返回码：1-127。这部分返回码一般用来作为给程序员自行设定错误退出用的返回码，比如：如果一个文件不存在，ls将返回2。如果要执行的命令不存在，则bash统一返回127<br>。返回码125和126有特殊用处，一个是程序命令不存在的返回码，另一个是命令的文件在，但是不可执行的返回码。</li>
<li>程序被信号打断的返回码：128-255。这部分系统习惯上是用来表示进程被信号打断的退出返回码的。一个进程如果被信号打断了，其退出返回码一般是128+信号编号的数字。</li>
</ul>
<p>比如说，如果一个进程被2号信号打断的话，其返回码一般是128+2=130。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ sleep 1000</div><div class="line">^C</div><div class="line">[zorro@zorrozou-pc0 bash]$ echo $?</div><div class="line">130</div></pre></td></tr></table></figure>
<p>在执行sleep命令的过程中，我使用ctrl+c中断了进程的执行。此时返回值为130。可以用内建命令kill -l查看所有信号和其对应的编号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[zorro@zorrozou-pc0 bash]$ kill -l</div><div class="line"> 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP</div><div class="line"> 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1</div><div class="line">11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM</div><div class="line">16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP</div><div class="line">21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ</div><div class="line">26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR</div><div class="line">31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</div><div class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</div><div class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</div><div class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</div><div class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</div><div class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</div><div class="line">63) SIGRTMAX-1  64) SIGRTMAX</div></pre></td></tr></table></figure>
<p>在我们编写bash脚本的时候，一般可以指定的返回码范围是1-124。建议大家养成编写返回码的编程习惯，但是系统并不对这做出限制，作为程序员你依然可以使用0-255的所有返回码。但是如果你滥用这些返回码，很可能会给未来程序的扩展造成不必要的麻烦。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文中我们描述了一个脚本的执行过程，从#!开始，到中间的解析过程，再到最后的退出返回码。希望这些对大家深入理解bash的执行过程和编写更高质量的脚本有帮助。通过本文我们明确了以下知识点：</p>
<ul>
<li>脚本开始的#!的作用原理。</li>
<li>bash的字符串解析过程。</li>
<li>什么是alias。</li>
<li>什么是关键字。</li>
<li>什么是function。</li>
<li>什么是内建命令，hash和外建命令以及它们的执行方法。</li>
<li>如何退出一个bash脚本以及返回码的含义。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/22/ansible/" title="初试ansible" itemprop="url">初试ansible</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="ericwang" target="_blank" itemprop="author">ericwang</a>
		
  <p class="article-time">
    <time datetime="2016-05-22T11:35:00.000Z" itemprop="datePublished"> Published 2016-05-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="ansible使用"><a href="#ansible使用" class="headerlink" title="ansible使用"></a>ansible使用</h1><p>ansible可以作为自动化运维工具，一直以来都是知道有这东西，却没有尝试过，现在是时候把吹过的牛逼补回来了</p>
<p>1、简介</p>
<p>ansible是自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。主要包括：</p>
<ul>
<li><p>连接插件connection plugins：负责和被监控端实现通信；</p>
</li>
<li><p>host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；</p>
</li>
<li><p>各种模块核心模块、command模块、自定义模块；</p>
</li>
<li><p>借助于插件完成记录日志邮件等功能；</p>
</li>
<li><p>playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>略过了，使用pip，安装很简单</p>
<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><p><img src="http://githubforericwang.qiniudn.com/hexo/eric/wKiom1Rsxz3ToUCAAAGROYAM3EI989.jpg" alt=""></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><p>no agents：不需要在被管控主机上安装任何客户端；</p>
</li>
<li><p>no server：无服务器端，使用时直接运行命令即可；</p>
</li>
<li><p>modules in any languages：基于模块工作，可使用任意语言开发模块；</p>
</li>
<li><p>yaml，not code：使用yaml语言定制剧本playbook；</p>
</li>
<li><p>ssh by default：基于SSH工作；</p>
</li>
<li><p>strong multi-tier solution：可实现多级指挥。</p>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；</li>
<li>批量任务执行可以写成脚本，而且不用分发到远程就可以执行；</li>
<li>使用python编写，维护更简单，ruby语法过于复杂；</li>
<li>支持sudo。</li>
</ul>
<h2 id="任务执行流程"><a href="#任务执行流程" class="headerlink" title="任务执行流程"></a>任务执行流程</h2><p><img src="http://githubforericwang.qiniudn.com/hexo/eric/wKiom1Rsx2uQYJZ5AAJplY08vOQ976.jpg" alt=""></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="搭建多个可操作的host"><a href="#搭建多个可操作的host" class="headerlink" title="搭建多个可操作的host"></a>搭建多个可操作的host</h3><p>没有机器，暂时用docker替代了<br>一个简单的sshd的Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FROM ubuntu:14.04</div><div class="line">MAINTAINER ericwang 123048591@qq.com</div><div class="line">RUN apt-get update &amp;&amp; apt-get install -y openssh-server \</div><div class="line">   &amp;&amp; sed -i &apos;s/UsePAM yes/UsePAM no/g&apos; /etc/ssh/sshd_config  \</div><div class="line">   &amp;&amp; useradd ansible \</div><div class="line">   &amp;&amp; echo ansible:ansible |chpasswd \</div><div class="line">   &amp;&amp; echo &quot;admin   ALL=(ALL)       ALL&quot; &gt;&gt; /etc/sudoers  \</div><div class="line">   &amp;&amp; mkdir /var/run/sshd</div><div class="line">RUN ssh-keygen  -t rsa -f /root/.ssh/id_rsa -P &quot;&quot;</div><div class="line">EXPOSE 22</div><div class="line">CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;]</div></pre></td></tr></table></figure>
<p>build脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">docker build  --tag sshd-server ./</div></pre></td></tr></table></figure>
<p>run脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">set -x</div><div class="line">container_id=$(docker run -itd -P sshd-server)</div><div class="line">cat ~/.ssh/id_rsa.pub | docker exec --user=root -i $container_id  sh -c &apos;cat &gt;&gt; /root/.ssh/authorized_keys&apos;</div><div class="line">docker exec $container_id chmod 600 /root/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<p>练习的时候才发现docker exec使用流的时候有些问题，google看到<a href="https://forums.docker.com/t/docker-exec-api-using-stdin-to-upload-a-file/748" target="_blank" rel="external">这篇文章</a>，直接使用exec command &gt;&gt; file这种形式是不行的，会把流输出到宿主系统，完全就是错误的。期待那位linux　大神继续更新shell相关的博文，更深入地理解linux</p>
<p>./build.sh 创建image,然后,./run.sh　这就创建了一个容器,也就是用来测试的ansible host。多次run后，就有了多个host机器了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps</div><div class="line"></div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                      NAMES</div><div class="line">a57b8c69e513        sshd-server         &quot;/usr/sbin/sshd -D&quot;      35 seconds ago      Up 34 seconds       0.0.0.0:32784-&gt;22/tcp      serene_saha</div></pre></td></tr></table></figure>
<p>每一次run后都会产生一个容器,将端口22映射到主机的一个端口上，可以通过ssh登陆到docker容器中<br>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  ~ ssh root@127.0.0.1 -p 32784</div><div class="line">The authenticity of host &apos;[127.0.0.1]:32784 ([127.0.0.1]:32784)&apos; can&apos;t be established.</div><div class="line">ECDSA key fingerprint is 6a:d1:27:e4:89:93:98:96:8f:02:f7:bf:6e:d7:eb:7b.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added &apos;[127.0.0.1]:32784&apos; (ECDSA) to the list of known hosts.</div><div class="line">root@a57b8c69e513:~#</div></pre></td></tr></table></figure></p>
<p>第一次登陆需要add到know hosts，以后就是免密码登陆了</p>
<p>启动了２个docker容器后,接下来是配置ansible了<br>默认hosts是在/etc/ansible/hosts,添加一组远程主机地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  ~ cat /etc/ansible/hosts </div><div class="line">[docker]</div><div class="line">[docker]</div><div class="line">127.0.0.1:32787 ansible_connection=ssh        ansible_ssh_user=root</div></pre></td></tr></table></figure>
<p>关于inventory的配置，这个<a href="http://sapser.github.io/ansible/2014/07/10/ansible-inventory/" target="_blank" rel="external">博客</a>写的很详尽</p>
<p>接下来尝试写playbook，<a href="http://sapser.github.io/ansible/2014/07/21/ansible-playbook/" target="_blank" rel="external">这篇</a>介绍的也不错。<br>写了一个简单的目录传输的playbook，很简单，功能很简单(其实就是发布系统的目录推送部分，其他功能待完善)<br>ansible目录下的两个文件,push_code.yml,update_git_code.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  ansible cat push_code.yml </div><div class="line">---</div><div class="line">- hosts: docker</div><div class="line">  remote_user: root</div><div class="line">  tasks:</div><div class="line">  - name: push data</div><div class="line">    copy: src=/data/git_code dest=/data/code/</div><div class="line">            owner=root group=root mode=0644</div></pre></td></tr></table></figure>
<p>然后写一个简单的主机发送脚本吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  ansible cat update_git_code.sh </div><div class="line">#!/bin/bash</div><div class="line">set -x</div><div class="line">cd dirname $0</div><div class="line">git_dir=/data/git_code/</div><div class="line">git --git-dir=$git_dir.git/ --work-tree=$git_dir pull --rebase origin master:master \</div><div class="line">&amp;&amp; ansible-playbook -check  push_code.yml</div></pre></td></tr></table></figure>
<p>/data/git_code是预先建立好的git代码仓库。这样就实现了一个简单的发布系统。后面有时间结合下之前做的docker-laravel,搞一个自动化的吧</p>
<p>ansible在github上也有关于lamp的例子<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="external">ansible-examples</a></p>
<p>就先这样吧　以后有机会再继续接触</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://sofar.blog.51cto.com/353572/1579894/" target="_blank" rel="external">自动化运维工具Ansible详细部署</a><br><a href="http://docs.ansible.com" target="_blank" rel="external">ansible 官方文档</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/linux/">linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/ansible/">ansible</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  
  <div class="tagcloudlist">
    <p class="asidetitle">Tag Cloud</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/C/" style="font-size: 13.33px;">C</a> <a href="/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/tags/arch/" style="font-size: 10px;">arch</a> <a href="/tags/bower/" style="font-size: 10px;">bower</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/elasticsearch/" style="font-size: 10px;">elasticsearch</a> <a href="/tags/git/" style="font-size: 11.67px;">git</a> <a href="/tags/http/" style="font-size: 13.33px;">http</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/laravel/" style="font-size: 10px;">laravel</a> <a href="/tags/linux/" style="font-size: 18.33px;">linux</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/nodejs/" style="font-size: 11.67px;">nodejs</a> <a href="/tags/patterns/" style="font-size: 11.67px;">patterns</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/rabbitmq/" style="font-size: 11.67px;">rabbitmq</a> <a href="/tags/redis/" style="font-size: 13.33px;">redis</a> <a href="/tags/rpc/" style="font-size: 10px;">rpc</a> <a href="/tags/shell/" style="font-size: 16.67px;">shell</a> <a href="/tags/singleton/" style="font-size: 10px;">singleton</a> <a href="/tags/solr/" style="font-size: 10px;">solr</a> <a href="/tags/urlencode/" style="font-size: 10px;">urlencode</a> <a href="/tags/varnish/" style="font-size: 10px;">varnish</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a>
    </div>
  </div>


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/C/" title="C">C<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/arch/" title="arch">arch<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/books/" title="books">books<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/git/" title="git">git<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/http/" title="http">http<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/java/" title="java">java<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/limux/" title="limux">limux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux/" title="linux">linux<sup>19</sup></a></li>
		  
		
		  
			<li><a href="/categories/mysql/" title="mysql">mysql<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/nginx/" title="nginx">nginx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/nodejs/" title="nodejs">nodejs<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/nosql/" title="nosql">nosql<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/other/" title="other">other<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/patterns/" title="patterns">patterns<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/php/" title="php">php<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/shell/" title="shell">shell<sup>1</sup></a></li>
		  
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="ericwang">ericwang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-47898532-4', 'auto');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
